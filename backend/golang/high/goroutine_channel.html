<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Golang 并发编程 | Hedon</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/noteSite/favicon.ico">
    <meta name="description" content="Just playing around">
    
    <link rel="preload" href="/noteSite/assets/css/0.styles.0f3b0cbd.css" as="style"><link rel="preload" href="/noteSite/assets/js/app.47f3dd69.js" as="script"><link rel="preload" href="/noteSite/assets/js/2.691adf44.js" as="script"><link rel="preload" href="/noteSite/assets/js/25.333b798b.js" as="script"><link rel="prefetch" href="/noteSite/assets/js/10.9a97bd95.js"><link rel="prefetch" href="/noteSite/assets/js/100.af239e1b.js"><link rel="prefetch" href="/noteSite/assets/js/101.ae26c2d8.js"><link rel="prefetch" href="/noteSite/assets/js/102.5fe90241.js"><link rel="prefetch" href="/noteSite/assets/js/103.97270f6a.js"><link rel="prefetch" href="/noteSite/assets/js/104.bb56eab1.js"><link rel="prefetch" href="/noteSite/assets/js/105.d14d5411.js"><link rel="prefetch" href="/noteSite/assets/js/106.f59ed55b.js"><link rel="prefetch" href="/noteSite/assets/js/107.5a6144f7.js"><link rel="prefetch" href="/noteSite/assets/js/108.583a3359.js"><link rel="prefetch" href="/noteSite/assets/js/109.aaff761d.js"><link rel="prefetch" href="/noteSite/assets/js/11.d6449e4b.js"><link rel="prefetch" href="/noteSite/assets/js/110.fa935a5e.js"><link rel="prefetch" href="/noteSite/assets/js/111.bd90aba0.js"><link rel="prefetch" href="/noteSite/assets/js/112.8b178fd9.js"><link rel="prefetch" href="/noteSite/assets/js/113.329df57c.js"><link rel="prefetch" href="/noteSite/assets/js/114.c9417ce6.js"><link rel="prefetch" href="/noteSite/assets/js/115.59711f27.js"><link rel="prefetch" href="/noteSite/assets/js/116.c871ff69.js"><link rel="prefetch" href="/noteSite/assets/js/117.b2d2bf69.js"><link rel="prefetch" href="/noteSite/assets/js/118.2726453b.js"><link rel="prefetch" href="/noteSite/assets/js/119.1724f0d3.js"><link rel="prefetch" href="/noteSite/assets/js/12.e733a196.js"><link rel="prefetch" href="/noteSite/assets/js/120.025bee0f.js"><link rel="prefetch" href="/noteSite/assets/js/121.ab209ac4.js"><link rel="prefetch" href="/noteSite/assets/js/122.cde88dad.js"><link rel="prefetch" href="/noteSite/assets/js/123.c90d4fad.js"><link rel="prefetch" href="/noteSite/assets/js/124.fbce8566.js"><link rel="prefetch" href="/noteSite/assets/js/125.3dcf3243.js"><link rel="prefetch" href="/noteSite/assets/js/126.962a9044.js"><link rel="prefetch" href="/noteSite/assets/js/127.c6c7a558.js"><link rel="prefetch" href="/noteSite/assets/js/128.de8a040e.js"><link rel="prefetch" href="/noteSite/assets/js/129.06d285f3.js"><link rel="prefetch" href="/noteSite/assets/js/13.2fb815a0.js"><link rel="prefetch" href="/noteSite/assets/js/130.9741d03f.js"><link rel="prefetch" href="/noteSite/assets/js/131.395ed3fc.js"><link rel="prefetch" href="/noteSite/assets/js/132.8830e1e4.js"><link rel="prefetch" href="/noteSite/assets/js/133.66eb8b6f.js"><link rel="prefetch" href="/noteSite/assets/js/134.615d0101.js"><link rel="prefetch" href="/noteSite/assets/js/135.c3d62164.js"><link rel="prefetch" href="/noteSite/assets/js/136.3628c7a8.js"><link rel="prefetch" href="/noteSite/assets/js/137.865054b3.js"><link rel="prefetch" href="/noteSite/assets/js/138.9b8c4da6.js"><link rel="prefetch" href="/noteSite/assets/js/139.68aab892.js"><link rel="prefetch" href="/noteSite/assets/js/14.f255fb4c.js"><link rel="prefetch" href="/noteSite/assets/js/140.5d41ef64.js"><link rel="prefetch" href="/noteSite/assets/js/141.c66dab2e.js"><link rel="prefetch" href="/noteSite/assets/js/142.9311cabe.js"><link rel="prefetch" href="/noteSite/assets/js/143.12af9100.js"><link rel="prefetch" href="/noteSite/assets/js/144.cde44442.js"><link rel="prefetch" href="/noteSite/assets/js/145.e191dc3f.js"><link rel="prefetch" href="/noteSite/assets/js/146.affabc0a.js"><link rel="prefetch" href="/noteSite/assets/js/147.368d3af1.js"><link rel="prefetch" href="/noteSite/assets/js/148.67db92ec.js"><link rel="prefetch" href="/noteSite/assets/js/149.a0864cdb.js"><link rel="prefetch" href="/noteSite/assets/js/15.75fb42a0.js"><link rel="prefetch" href="/noteSite/assets/js/150.223475d5.js"><link rel="prefetch" href="/noteSite/assets/js/151.112f1a94.js"><link rel="prefetch" href="/noteSite/assets/js/152.3c605cc7.js"><link rel="prefetch" href="/noteSite/assets/js/153.03cc572c.js"><link rel="prefetch" href="/noteSite/assets/js/154.51ac4148.js"><link rel="prefetch" href="/noteSite/assets/js/155.2c521802.js"><link rel="prefetch" href="/noteSite/assets/js/156.0ac68600.js"><link rel="prefetch" href="/noteSite/assets/js/157.f95a974d.js"><link rel="prefetch" href="/noteSite/assets/js/158.61717b99.js"><link rel="prefetch" href="/noteSite/assets/js/159.a6605cd2.js"><link rel="prefetch" href="/noteSite/assets/js/16.c118e0d3.js"><link rel="prefetch" href="/noteSite/assets/js/160.1a36cc4d.js"><link rel="prefetch" href="/noteSite/assets/js/161.1e48de77.js"><link rel="prefetch" href="/noteSite/assets/js/162.a3667ac3.js"><link rel="prefetch" href="/noteSite/assets/js/163.8985161c.js"><link rel="prefetch" href="/noteSite/assets/js/164.06526f18.js"><link rel="prefetch" href="/noteSite/assets/js/165.73faf46b.js"><link rel="prefetch" href="/noteSite/assets/js/166.afc73ad0.js"><link rel="prefetch" href="/noteSite/assets/js/167.36a08e5e.js"><link rel="prefetch" href="/noteSite/assets/js/168.95cb161a.js"><link rel="prefetch" href="/noteSite/assets/js/169.d0464c02.js"><link rel="prefetch" href="/noteSite/assets/js/17.42c5f955.js"><link rel="prefetch" href="/noteSite/assets/js/170.5ff197f3.js"><link rel="prefetch" href="/noteSite/assets/js/171.ae845398.js"><link rel="prefetch" href="/noteSite/assets/js/172.40a661c8.js"><link rel="prefetch" href="/noteSite/assets/js/173.389ebc0e.js"><link rel="prefetch" href="/noteSite/assets/js/174.e7824765.js"><link rel="prefetch" href="/noteSite/assets/js/175.7ebc5f29.js"><link rel="prefetch" href="/noteSite/assets/js/176.9136d8c6.js"><link rel="prefetch" href="/noteSite/assets/js/177.1407812e.js"><link rel="prefetch" href="/noteSite/assets/js/178.6dc811d8.js"><link rel="prefetch" href="/noteSite/assets/js/18.7a2f817c.js"><link rel="prefetch" href="/noteSite/assets/js/19.13241de9.js"><link rel="prefetch" href="/noteSite/assets/js/20.fdf3ee8c.js"><link rel="prefetch" href="/noteSite/assets/js/21.ed6203ac.js"><link rel="prefetch" href="/noteSite/assets/js/22.e6553a1c.js"><link rel="prefetch" href="/noteSite/assets/js/23.f8f9c155.js"><link rel="prefetch" href="/noteSite/assets/js/24.7382ddd7.js"><link rel="prefetch" href="/noteSite/assets/js/26.cce0d974.js"><link rel="prefetch" href="/noteSite/assets/js/27.190cdf57.js"><link rel="prefetch" href="/noteSite/assets/js/28.3cd8d62d.js"><link rel="prefetch" href="/noteSite/assets/js/29.8ba6931d.js"><link rel="prefetch" href="/noteSite/assets/js/3.15783b20.js"><link rel="prefetch" href="/noteSite/assets/js/30.1e496c21.js"><link rel="prefetch" href="/noteSite/assets/js/31.63c482b8.js"><link rel="prefetch" href="/noteSite/assets/js/32.87605845.js"><link rel="prefetch" href="/noteSite/assets/js/33.62d5d237.js"><link rel="prefetch" href="/noteSite/assets/js/34.a3c3e9b1.js"><link rel="prefetch" href="/noteSite/assets/js/35.5dcc538b.js"><link rel="prefetch" href="/noteSite/assets/js/36.8c2a6633.js"><link rel="prefetch" href="/noteSite/assets/js/37.8dc4cab2.js"><link rel="prefetch" href="/noteSite/assets/js/38.5bf321b5.js"><link rel="prefetch" href="/noteSite/assets/js/39.5d6c1ff5.js"><link rel="prefetch" href="/noteSite/assets/js/4.a61e4cea.js"><link rel="prefetch" href="/noteSite/assets/js/40.2a1e9668.js"><link rel="prefetch" href="/noteSite/assets/js/41.64b3da69.js"><link rel="prefetch" href="/noteSite/assets/js/42.9df0329c.js"><link rel="prefetch" href="/noteSite/assets/js/43.a3e89e35.js"><link rel="prefetch" href="/noteSite/assets/js/44.5b7109ba.js"><link rel="prefetch" href="/noteSite/assets/js/45.b3fd2486.js"><link rel="prefetch" href="/noteSite/assets/js/46.7197c6a0.js"><link rel="prefetch" href="/noteSite/assets/js/47.7ae7f7c0.js"><link rel="prefetch" href="/noteSite/assets/js/48.23249fd1.js"><link rel="prefetch" href="/noteSite/assets/js/49.4f8a9444.js"><link rel="prefetch" href="/noteSite/assets/js/5.2bccd6df.js"><link rel="prefetch" href="/noteSite/assets/js/50.1ccd8f6d.js"><link rel="prefetch" href="/noteSite/assets/js/51.bce52934.js"><link rel="prefetch" href="/noteSite/assets/js/52.16a2b899.js"><link rel="prefetch" href="/noteSite/assets/js/53.7c086f8c.js"><link rel="prefetch" href="/noteSite/assets/js/54.abd84d8b.js"><link rel="prefetch" href="/noteSite/assets/js/55.fab87694.js"><link rel="prefetch" href="/noteSite/assets/js/56.03713098.js"><link rel="prefetch" href="/noteSite/assets/js/57.ce995f0a.js"><link rel="prefetch" href="/noteSite/assets/js/58.e82c9cee.js"><link rel="prefetch" href="/noteSite/assets/js/59.917c2f49.js"><link rel="prefetch" href="/noteSite/assets/js/6.f3d86aa7.js"><link rel="prefetch" href="/noteSite/assets/js/60.0cb171dc.js"><link rel="prefetch" href="/noteSite/assets/js/61.c1087596.js"><link rel="prefetch" href="/noteSite/assets/js/62.879edb90.js"><link rel="prefetch" href="/noteSite/assets/js/63.d6ce7c96.js"><link rel="prefetch" href="/noteSite/assets/js/64.e9bcd097.js"><link rel="prefetch" href="/noteSite/assets/js/65.3b44bb75.js"><link rel="prefetch" href="/noteSite/assets/js/66.cf292c79.js"><link rel="prefetch" href="/noteSite/assets/js/67.ef42faf6.js"><link rel="prefetch" href="/noteSite/assets/js/68.e6fa6e97.js"><link rel="prefetch" href="/noteSite/assets/js/69.e86f9e8f.js"><link rel="prefetch" href="/noteSite/assets/js/7.da9921ea.js"><link rel="prefetch" href="/noteSite/assets/js/70.f6816715.js"><link rel="prefetch" href="/noteSite/assets/js/71.89924f1c.js"><link rel="prefetch" href="/noteSite/assets/js/72.d1defce3.js"><link rel="prefetch" href="/noteSite/assets/js/73.3728ae97.js"><link rel="prefetch" href="/noteSite/assets/js/74.cefe37e6.js"><link rel="prefetch" href="/noteSite/assets/js/75.d2a9f8d7.js"><link rel="prefetch" href="/noteSite/assets/js/76.2edaa075.js"><link rel="prefetch" href="/noteSite/assets/js/77.4836da79.js"><link rel="prefetch" href="/noteSite/assets/js/78.8016a351.js"><link rel="prefetch" href="/noteSite/assets/js/79.c47c628e.js"><link rel="prefetch" href="/noteSite/assets/js/8.b1ba721d.js"><link rel="prefetch" href="/noteSite/assets/js/80.61be3846.js"><link rel="prefetch" href="/noteSite/assets/js/81.34ef4f6e.js"><link rel="prefetch" href="/noteSite/assets/js/82.d89892fc.js"><link rel="prefetch" href="/noteSite/assets/js/83.3bba8b06.js"><link rel="prefetch" href="/noteSite/assets/js/84.c2271ec9.js"><link rel="prefetch" href="/noteSite/assets/js/85.43108acb.js"><link rel="prefetch" href="/noteSite/assets/js/86.38a23363.js"><link rel="prefetch" href="/noteSite/assets/js/87.13c6644a.js"><link rel="prefetch" href="/noteSite/assets/js/88.034fd132.js"><link rel="prefetch" href="/noteSite/assets/js/89.10e5b366.js"><link rel="prefetch" href="/noteSite/assets/js/9.09db9bdb.js"><link rel="prefetch" href="/noteSite/assets/js/90.738664f9.js"><link rel="prefetch" href="/noteSite/assets/js/91.90bbef34.js"><link rel="prefetch" href="/noteSite/assets/js/92.b0b80dd7.js"><link rel="prefetch" href="/noteSite/assets/js/93.7cd8efa5.js"><link rel="prefetch" href="/noteSite/assets/js/94.87784807.js"><link rel="prefetch" href="/noteSite/assets/js/95.a0f509c1.js"><link rel="prefetch" href="/noteSite/assets/js/96.68407d3e.js"><link rel="prefetch" href="/noteSite/assets/js/97.edf26645.js"><link rel="prefetch" href="/noteSite/assets/js/98.f888cfc7.js"><link rel="prefetch" href="/noteSite/assets/js/99.c724368c.js">
    <link rel="stylesheet" href="/noteSite/assets/css/0.styles.0f3b0cbd.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/noteSite/" class="home-link router-link-active"><img src="/noteSite/images/hedon.png" alt="Hedon" class="logo"> <span class="site-name can-hide">Hedon</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/noteSite/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/noteSite/guide/" class="nav-link">
  Guide
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="CS Menu" class="dropdown-title"><span class="title">计算机基础</span> <span class="arrow down"></span></button> <button type="button" aria-label="CS Menu" class="mobile-dropdown-title"><span class="title">计算机基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/noteSite/cs/mysql/" class="nav-link">
  MySQL
</a></li><li class="dropdown-item"><!----> <a href="/noteSite/cs/os/" class="nav-link">
  操作系统
</a></li><li class="dropdown-item"><!----> <a href="/noteSite/cs/cn/" class="nav-link">
  计算机网络
</a></li><li class="dropdown-item"><!----> <a href="/noteSite/cs/component/" class="nav-link">
  计算机组成原理
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Backend Menu" class="dropdown-title"><span class="title">后端</span> <span class="arrow down"></span></button> <button type="button" aria-label="Backend Menu" class="mobile-dropdown-title"><span class="title">后端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/noteSite/backend/java/" class="nav-link">
  Java
</a></li><li class="dropdown-item"><!----> <a href="/noteSite/backend/golang/" class="nav-link router-link-active">
  Golang
</a></li><li class="dropdown-item"><!----> <a href="/noteSite/backend/middleware/" class="nav-link">
  中间件
</a></li></ul></div></div><div class="nav-item"><a href="/noteSite/frontend/" class="nav-link">
  前端
</a></div><div class="nav-item"><a href="/noteSite/linux/" class="nav-link">
  Linux
</a></div><div class="nav-item"><a href="/noteSite/mac/" class="nav-link">
  Mac
</a></div><div class="nav-item"><a href="/noteSite/leetcode/" class="nav-link">
  Leetcode
</a></div><div class="nav-item"><a href="/noteSite/paper/" class="nav-link">
  Paper
</a></div><div class="nav-item"><a href="https://github.com/hedon954/noteSite" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/noteSite/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/noteSite/guide/" class="nav-link">
  Guide
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="CS Menu" class="dropdown-title"><span class="title">计算机基础</span> <span class="arrow down"></span></button> <button type="button" aria-label="CS Menu" class="mobile-dropdown-title"><span class="title">计算机基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/noteSite/cs/mysql/" class="nav-link">
  MySQL
</a></li><li class="dropdown-item"><!----> <a href="/noteSite/cs/os/" class="nav-link">
  操作系统
</a></li><li class="dropdown-item"><!----> <a href="/noteSite/cs/cn/" class="nav-link">
  计算机网络
</a></li><li class="dropdown-item"><!----> <a href="/noteSite/cs/component/" class="nav-link">
  计算机组成原理
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Backend Menu" class="dropdown-title"><span class="title">后端</span> <span class="arrow down"></span></button> <button type="button" aria-label="Backend Menu" class="mobile-dropdown-title"><span class="title">后端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/noteSite/backend/java/" class="nav-link">
  Java
</a></li><li class="dropdown-item"><!----> <a href="/noteSite/backend/golang/" class="nav-link router-link-active">
  Golang
</a></li><li class="dropdown-item"><!----> <a href="/noteSite/backend/middleware/" class="nav-link">
  中间件
</a></li></ul></div></div><div class="nav-item"><a href="/noteSite/frontend/" class="nav-link">
  前端
</a></div><div class="nav-item"><a href="/noteSite/linux/" class="nav-link">
  Linux
</a></div><div class="nav-item"><a href="/noteSite/mac/" class="nav-link">
  Mac
</a></div><div class="nav-item"><a href="/noteSite/leetcode/" class="nav-link">
  Leetcode
</a></div><div class="nav-item"><a href="/noteSite/paper/" class="nav-link">
  Paper
</a></div><div class="nav-item"><a href="https://github.com/hedon954/noteSite" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>入门</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>基础</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>进阶</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/noteSite/backend/golang/high/goroutine_channel.html" aria-current="page" class="active sidebar-link">Golang 并发编程</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/noteSite/backend/golang/high/goroutine_channel.html#一、并发性-concurrency" class="sidebar-link">一、并发性 Concurrency</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/noteSite/backend/golang/high/goroutine_channel.html#_1-多任务" class="sidebar-link">1. 多任务</a></li><li class="sidebar-sub-header"><a href="/noteSite/backend/golang/high/goroutine_channel.html#_1-2-并发" class="sidebar-link">1.2 并发</a></li><li class="sidebar-sub-header"><a href="/noteSite/backend/golang/high/goroutine_channel.html#_1-3-进程-线程-协程" class="sidebar-link">1.3 进程/线程/协程</a></li></ul></li><li class="sidebar-sub-header"><a href="/noteSite/backend/golang/high/goroutine_channel.html#二、goroutine" class="sidebar-link">二、Goroutine</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/noteSite/backend/golang/high/goroutine_channel.html#_1-goroutine" class="sidebar-link">1. Goroutine</a></li><li class="sidebar-sub-header"><a href="/noteSite/backend/golang/high/goroutine_channel.html#_2-主-goroutine" class="sidebar-link">2. 主 Goroutine</a></li><li class="sidebar-sub-header"><a href="/noteSite/backend/golang/high/goroutine_channel.html#_3-使用-goroutine" class="sidebar-link">3. 使用 Goroutine</a></li><li class="sidebar-sub-header"><a href="/noteSite/backend/golang/high/goroutine_channel.html#_4-启动多个-goroutine" class="sidebar-link">4. 启动多个 Goroutine</a></li></ul></li><li class="sidebar-sub-header"><a href="/noteSite/backend/golang/high/goroutine_channel.html#三、go-语言并发模型" class="sidebar-link">三、Go 语言并发模型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/noteSite/backend/golang/high/goroutine_channel.html#_1-线程模型" class="sidebar-link">1. 线程模型</a></li><li class="sidebar-sub-header"><a href="/noteSite/backend/golang/high/goroutine_channel.html#_2-go-并发模型-gpm-模型" class="sidebar-link">2. Go 并发模型 —— GPM 模型</a></li><li class="sidebar-sub-header"><a href="/noteSite/backend/golang/high/goroutine_channel.html#_3-runtime-包" class="sidebar-link">3. runtime 包</a></li></ul></li><li class="sidebar-sub-header"><a href="/noteSite/backend/golang/high/goroutine_channel.html#四、临界资源安全问题" class="sidebar-link">四、临界资源安全问题</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/noteSite/backend/golang/high/goroutine_channel.html#_1-临界资源" class="sidebar-link">1. 临界资源</a></li><li class="sidebar-sub-header"><a href="/noteSite/backend/golang/high/goroutine_channel.html#_2-临界资源安全问题" class="sidebar-link">2. 临界资源安全问题</a></li><li class="sidebar-sub-header"><a href="/noteSite/backend/golang/high/goroutine_channel.html#_3-解决临界资源问题" class="sidebar-link">3. 解决临界资源问题</a></li><li class="sidebar-sub-header"><a href="/noteSite/backend/golang/high/goroutine_channel.html#_4-sync-包" class="sidebar-link">4. sync 包</a></li></ul></li><li class="sidebar-sub-header"><a href="/noteSite/backend/golang/high/goroutine_channel.html#五、channel-通道" class="sidebar-link">五、channel 通道</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/noteSite/backend/golang/high/goroutine_channel.html#_1-通道的概念" class="sidebar-link">1. 通道的概念</a></li><li class="sidebar-sub-header"><a href="/noteSite/backend/golang/high/goroutine_channel.html#_2-通道的声明" class="sidebar-link">2. 通道的声明</a></li><li class="sidebar-sub-header"><a href="/noteSite/backend/golang/high/goroutine_channel.html#_3-通道的语法" class="sidebar-link">3. 通道的语法</a></li><li class="sidebar-sub-header"><a href="/noteSite/backend/golang/high/goroutine_channel.html#_4-通道注意点" class="sidebar-link">4. 通道注意点</a></li><li class="sidebar-sub-header"><a href="/noteSite/backend/golang/high/goroutine_channel.html#_5-通道的阻塞" class="sidebar-link">5. 通道的阻塞</a></li><li class="sidebar-sub-header"><a href="/noteSite/backend/golang/high/goroutine_channel.html#_6-通道的死锁" class="sidebar-link">6. 通道的死锁</a></li><li class="sidebar-sub-header"><a href="/noteSite/backend/golang/high/goroutine_channel.html#_7-通道的关闭" class="sidebar-link">7. 通道的关闭</a></li><li class="sidebar-sub-header"><a href="/noteSite/backend/golang/high/goroutine_channel.html#_8-通道的遍历" class="sidebar-link">8. 通道的遍历</a></li><li class="sidebar-sub-header"><a href="/noteSite/backend/golang/high/goroutine_channel.html#_9-通道的调度" class="sidebar-link">9. 通道的调度</a></li><li class="sidebar-sub-header"><a href="/noteSite/backend/golang/high/goroutine_channel.html#_10-通道与-time" class="sidebar-link">10. 通道与 time</a></li></ul></li><li class="sidebar-sub-header"><a href="/noteSite/backend/golang/high/goroutine_channel.html#六、golang-csp-模型" class="sidebar-link">六、Golang CSP 模型</a></li></ul></li><li><a href="/noteSite/backend/golang/high/reflect.html" class="sidebar-link">Golang 反射</a></li><li><a href="/noteSite/backend/golang/high/net.html" class="sidebar-link">Golang 网络编程</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>标准库</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>常用技巧</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="golang-并发编程"><a href="#golang-并发编程" class="header-anchor">#</a> Golang 并发编程</h1> <ul><li>什么是并发编程</li> <li>什么是并行，并发，串行</li> <li>Go 语言如何实现并发编程，以及实现的原理</li> <li>goroutine 的使用</li> <li>runtime 包</li> <li>sync 包的介绍</li> <li>channel 通道的使用，以及缓冲通道，定向通道</li> <li>select 语句</li> <li>time 包中和并发编程相关的函数介绍</li> <li>CSP 模型</li></ul> <h2 id="一、并发性-concurrency"><a href="#一、并发性-concurrency" class="header-anchor">#</a> 一、并发性 Concurrency</h2> <h3 id="_1-多任务"><a href="#_1-多任务" class="header-anchor">#</a> 1. 多任务</h3> <p>怎么来理解多任务呢？其实就是指我们的操作系统可以同时执行多个任务。举个例子，你一边听音乐，一边刷微博，一边聊 QQ，一边用Markdown 写作业，这就是多任务，至少同时有4个任务正在运行。还有很多任务悄悄地在后台同时运行着，只是界面上没有显示而已。</p> <img src="https://tva1.sinaimg.cn/large/008i3skNly1gsnhy2t6h4j30dw0ev3ze.jpg" alt="img" style="zoom:50%;"> <h3 id="_1-2-并发"><a href="#_1-2-并发" class="header-anchor">#</a> 1.2 并发</h3> <p>Go 是并发语言，而不是并行语言。在讨论如何在 Go 中进行并发处理之前，我们首先必须了解什么是并发，以及它与并行性有什么不同。</p> <blockquote><p>Go is a concurrent language and not a parallel one.</p></blockquote> <p><strong>并发性 Concurrency 是同时处理许多事情的能力</strong></p> <p><strong>并行就是同时做很多事情。</strong></p> <img src="https://tva1.sinaimg.cn/large/008i3skNly1gsnhz810r5j30lv0iggn6.jpg" alt="img" style="zoom:50%;"> <h3 id="_1-3-进程-线程-协程"><a href="#_1-3-进程-线程-协程" class="header-anchor">#</a> 1.3 进程/线程/协程</h3> <p><strong>进程</strong></p> <p>进程是一个程序在一个数据集中的一次动态执行过程，可以简单理解为“正在执行的程序”，它是 CPU 资源分配和调度的独立单位。</p> <p>进程一般由程序、数据集、进程控制块三部分组成。我们编写的程序用来描述进程要完成哪些功能以及如何完成；数据集则是程序在执行过程中所需要使用的资源；进程控制块用来记录进程的外部特征，描述进程的执行变化过程，系统可以利用它来控制和管理进程，它是系统感知进程存在的唯一标志。</p> <p>进程的局限是创建、撤销和切换的开销比较大。</p> <p><strong>线程</strong></p> <p>线程是在进程之后发展出来的概念。 线程也叫轻量级进程，它是一个基本的 CPU 执行单元，也是程序执行过程中的最小单元，由线程 ID、程序计数器、寄存器集合和堆栈共同组成。</p> <p>一个进程可以包含多个线程。</p> <p>线程的优点是减小了程序并发执行时的开销，提高了操作系统的并发性能，缺点是线程没有自己的系统资源，只拥有在运行时必不可少的资源，但同一进程的各线程可以共享进程所拥有的系统资源，如果把进程比作一个车间，那么线程就好比是车间里面的工人。不过对于某些独占性资源存在锁机制，处理不当可能会产生“死锁”。</p> <p><strong>协程</strong></p> <p>协程是一种用户态的轻量级线程，又称微线程，英文名 Coroutine，协程的调度完全由用户控制。人们通常将协程和子程序（函数）比较着理解。</p> <p>子程序调用总是一个入口，一次返回，一旦退出即完成了子程序的执行。</p> <blockquote><p>与传统的系统级线程和进程相比，协程的最大优势在于其&quot;<strong>轻量级</strong>&quot;，可以轻松创建上百万个而不会导致系统资源衰竭，而线程和进程通常最多也不能超过 1 万的。这也是协程也叫轻量级线程的原因。</p> <p>协程与多线程相比，其优势体现在：协程的执行效率极高。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。</p></blockquote> <p><strong>Go语言对于并发的实现是靠协程，Goroutine</strong></p> <h2 id="二、goroutine"><a href="#二、goroutine" class="header-anchor">#</a> 二、Goroutine</h2> <h3 id="_1-goroutine"><a href="#_1-goroutine" class="header-anchor">#</a> 1. Goroutine</h3> <p>Goroutine 是 Go 语言特有的名词。区别于进程 Process，线程 Thread，协程 Coroutine，因为 Go 语言的创造者们觉得和他们是有所区别的，所以专门创造了 Goroutine。</p> <p><strong>Goroutine 是与其他函数或方法同时运行的函数或方法。</strong> Goroutines 可以被认为是轻量级的线程。与线程相比，创建 Goroutine 的成本很小，它就是一段代码，一个函数入口。以及在堆上为其分配的一个堆栈（初始大小为 <strong>4K</strong>，会随着程序的执行自动增长删除）。因此它非常廉价，Go 应用程序可以并发运行数千个 Goroutines。</p> <blockquote><p><strong>Goroutine 在线程上的优势：</strong></p> <ol><li><p>与线程相比，Goroutine 非常便宜。它们只是堆栈大小的几个 kb，堆栈可以根据应用程序的需要增长和收缩。</p> <p>而在线程的情况下，堆栈大小必须指定并且是固定的。</p></li> <li><p>Goroutine 被多路复用到较少的 OS 线程。在一个程序中可能只有一个线程与数千个 Goroutine。</p> <p>如果线程中的任何 Goroutine 都表示等待用户输入，则会创建另一个 OS 线程，剩下的 Goroutine 被转移到新的 OS 线程。</p> <p>所有这些都由运行时进行处理，我们作为程序员从这些复杂的细节中抽象出来，并得到了一个与并发工作相关的干净的 API。</p></li> <li><p>当使用 Goroutine 访问共享内存时，通过设计的通道（channel）可以防止竞态条件发生。</p> <p>通道可以被认为是 Goroutine 通信的管道。</p></li></ol></blockquote> <h3 id="_2-主-goroutine"><a href="#_2-主-goroutine" class="header-anchor">#</a> 2. 主 Goroutine</h3> <blockquote><p>封装 <strong>main</strong> 函数的 Goroutine 称为主 Goroutine。</p></blockquote> <p><strong>主 Goroutine 所做的事情并不是执行 main 函数那么简单。它首先要做的是：设定每一个 Goroutine 所能申请的栈空间的最大尺寸。在 32 位的计算机系统中此最大尺寸为 250MB，而在 64 位的计算机系统中此尺寸为 1GB。如果有某个 Goroutine 的栈空间尺寸大于这个限制，那么运行时系统就会引发一个栈溢出（stack overflow）的运行时 panic。随后，这个 Go 程序的运行也会终止。</strong></p> <p>此后，主 Goroutine 会进行一系列的初始化工作，涉及的工作内容大致如下：</p> <ol><li>创建一个特殊的 defer 语句，用于在主 Goroutine 退出时做必要的善后处理。因为主 Goroutine 也可能非正常的结束</li> <li>启动专用于在后台清扫内存垃圾的 Goroutine，并设置 GC 可用的标识</li> <li>执行 main 包中的 init 函数</li> <li>执行 main 函数</li> <li>执行完 main 函数后，它还会检查主 Goroutine 是否引发了运行时恐慌（panic），并进行必要的处理</li> <li>最后主 Goroutine 会结束自己以及当前进程的运行</li></ol> <h3 id="_3-使用-goroutine"><a href="#_3-使用-goroutine" class="header-anchor">#</a> 3. 使用 Goroutine</h3> <blockquote><p>创建一个 Goroutine 非常简单，只需要在函数或方法调用前面加上关键字 go，就可以创建一个新的 Goroutine。</p></blockquote> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">&quot;fmt&quot;</span>
	<span class="token string">&quot;time&quot;</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;Hello world, Goroutine.&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>


<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>
	<span class="token keyword">go</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token comment">// 睡眠一下，防止 Goroutine 还没创建并执行完成主 Goroutine 就已经结束了，这样进程就结束了，hello() 也就不会执行了</span>
	time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">10</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Millisecond<span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;main function&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>输出：</p> <div class="language- extra-class"><pre class="language-text"><code>Hello world, Goroutine.
main function
</code></pre></div><p>分析：</p> <ol><li>当新的 Goroutine 开始时，Goroutine 调用立即返回。与函数不同，Go 不等待 Goroutine 执行结束。当 Goroutine 调用，并且Goroutine 的任何返回值被忽略之后，Go 立即执行到下一行代码。</li> <li>main 的 Goroutine 应该为其他的 Goroutine 执行。如果 main 的 Goroutine 终止了，程序将被终止，而其他 Goroutine 将不会运行。所以如果我们不睡眠的话，是有可能只输出 <code>main function</code> 的。</li></ol> <h3 id="_4-启动多个-goroutine"><a href="#_4-启动多个-goroutine" class="header-anchor">#</a> 4. 启动多个 Goroutine</h3> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>  
    <span class="token string">&quot;fmt&quot;</span>
    <span class="token string">&quot;time&quot;</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">numbers</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
        time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">250</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Millisecond<span class="token punctuation">)</span>
        fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d &quot;</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token function">alphabets</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token string">'a'</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token string">'e'</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
        time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">400</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Millisecond<span class="token punctuation">)</span>
        fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">&quot;%c &quot;</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
    <span class="token keyword">go</span> <span class="token function">numbers</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
    <span class="token keyword">go</span> <span class="token function">alphabets</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">3000</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Millisecond<span class="token punctuation">)</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;main terminated&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>输出：</p> <div class="language- extra-class"><pre class="language-text"><code>1 a 2 3 b 4 c 5 d e main terminated  
</code></pre></div><p>分析：</p> <p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gsnidy6hbtj30wo0hwmy9.jpg" alt="img"></p> <h2 id="三、go-语言并发模型"><a href="#三、go-语言并发模型" class="header-anchor">#</a> 三、Go 语言并发模型</h2> <p>Go 语言相比 Java 等一个很大的优势就是可以方便地编写并发程序。Go 语言内置了 Goroutine 机制，使用 Goroutine 可以快速地开发并发程序， 更好的利用多核处理器资源。接下来我们来了解一下 Go 语言的并发原理。</p> <h3 id="_1-线程模型"><a href="#_1-线程模型" class="header-anchor">#</a> 1. 线程模型</h3> <p>在现代操作系统中，<strong>线程是处理器调度和分配的基本单位，进程则作为资源拥有的基本单位。</strong> 每个进程是由私有的虚拟地址空间、代码、数据和其它各种系统资源组成。线程是进程内部的一个执行单元。 每一个进程至少有一个主执行线程，它无需由用户去主动创建，是由系统自动创建的。 用户根据需要在应用程序中创建其它线程，多个线程并发地运行于同一个进程中。</p> <p>我们先从线程讲起，<strong>无论语言层面何种并发模型，到了操作系统层面，一定是以线程的形态存在的。</strong> 而操作系统根据资源访问权限的不同，体系架构可分为用户空间和内核空间：</p> <ul><li>内核空间主要操作访问 CPU 资源、I/O 资源、内存资源等硬件资源，为上层应用程序提供最基本的基础资源</li> <li>用户空间就是上层应用程序的固定活动空间，用户空间不可以直接访问资源，必须通过“系统调用”、“库函数”或“ Shell 脚本”来调用内核空间提供的资源</li></ul> <p>我们现在的计算机语言，可以狭义的认为是一种“软件”，它们中所谓的“线程”，<strong>往往是用户态的线程</strong>，和操作系统本身内核态的线程（简称 KSE），还是有区别的。</p> <p>Go 并发编程模型在底层是由操作系统所提供的线程库支撑的，因此还是得从线程实现模型说起。</p> <p>线程可以视为进程中的控制流。一个进程至少会包含一个线程，因为其中至少会有一个控制流持续运行。因而，一个进程的第一个线程会随着这个进程的启动而创建，这个线程称为该进程的主线程。当然，一个进程也可以包含多个线程。这些线程都是由当前进程中已存在的线程创建出来的，创建的方法就是调用系统调用，更确切地说是调用 <code>pthread create</code> 函数。</p> <p>拥有多个线程的进程可以并发执行多个任务，并且即使某个或某些任务被阻塞，也不会影响其他任务正常执行，这可以大大改善程序的响应时间和吞吐量。另一方面，线程不可能独立于进程存在。它的生命周期不可能逾越其所属进程的生命周期。</p> <p>线程的实现模型主要有 3 个，分别是：</p> <ul><li>用户级线程模型</li> <li>内核级线程模型</li> <li>两级线程模型</li></ul> <p>它们之间最大的差异就在于线程与内核调度实体（Kernel Scheduling Entity，简称 KSE）之间的对应关系上。顾名思义，内核调度实体就是可以被内核的调度器调度的对象。在很多文献和书中，它也称为内核级线程，是操作系统内核的最小调度单元。</p> <h4 id="_1-1-内核级线程模型"><a href="#_1-1-内核级线程模型" class="header-anchor">#</a> 1.1 内核级线程模型</h4> <blockquote><p>用户线程与 KSE 是1对1关系（1:1）。</p></blockquote> <p>大部分编程语言的线程库（如 Linux 的 pthread，Java 的 java.lang.Thread，C++11 的 std::thread 等等）都是对操作系统的线程（内核级线程）的一层封装，创建出来的每个线程与一个不同的 KSE 静态关联，因此其调度完全由 OS 调度器来做。</p> <p>这种方式实现简单，直接借助 OS 提供的线程能力，并且不同用户线程之间一般也不会相互影响。但其创建，销毁以及多个线程之间的上下文切换等操作都是直接由 OS 层面亲自来做，在需要使用大量线程的场景下对 OS 的性能影响会很大。</p> <img src="https://tva1.sinaimg.cn/large/008i3skNly1gsniksv27qj30yg0kowfg.jpg" alt="img" style="zoom:50%;"> <p>每个线程由内核调度器独立的调度，所以如果一个线程阻塞则不影响其他的线程。</p> <p>优点：</p> <ul><li>在多核处理器的硬件的支持下，内核空间线程模型支持了真正的并行，当一个线程被阻塞后，允许另一个线程继续执行，所以并发能力较强。</li></ul> <p>缺点：</p> <ul><li>每创建一个用户级线程都需要创建一个内核级线程与其对应，这样创建线程的开销比较大，会影响到应用程序的性能。</li></ul> <h4 id="_1-2-用户级线程模型"><a href="#_1-2-用户级线程模型" class="header-anchor">#</a> 1.2 用户级线程模型</h4> <blockquote><p>用户线程与 KSE 是多对一关系（M:1)。</p></blockquote> <p>这种线程的创建，销毁以及多个线程之间的协调等操作都是由用户自己实现的线程库来负责，对 OS 内核透明，一个进程中所有创建的线程都与同一个 KSE 在运行时动态关联。</p> <p>现在有许多语言实现的 <strong>协程</strong> 基本上都属于这种方式。这种实现方式相比内核级线程可以做的很轻量级，对系统资源的消耗会小很多，因此可以创建的数量与上下文切换所花费的代价也会小得多。</p> <p>但该模型有个致命的缺点：</p> <ul><li><strong>如果我们在某个用户线程上调用阻塞式系统调用（如用阻塞方式 read 网络 IO)，那么一旦 KSE 因阻塞被内核调度出 CPU 的话，剩下的所有对应的用户线程全都会变为阻塞状态（整个进程挂起）。</strong></li></ul> <p>所以这些语言的 <strong>协程库</strong> 会把自己一些阻塞的操作重新封装为完全的非阻塞形式，然后在以前要阻塞的点上，主动让出自己，并通过某种方式通知或唤醒其他待执行的用户线程在该 KSE 上运行，从而避免了内核调度器由于 KSE 阻塞而做上下文切换，这样整个进程也不会被阻塞了。</p> <img src="https://tva1.sinaimg.cn/large/008i3skNly1gsnimp8h1mj30yg0khdgl.jpg" alt="img" style="zoom:50%;"> <p>优点：</p> <ul><li>这种模型的好处是线程上下文切换都发生在用户空间，避免的模态切换（mode switch），从而对于性能有积极的影响。</li></ul> <p>缺点：</p> <ul><li>所有的线程基于一个内核调度实体即内核线程，这意味着只有一个处理器可以被利用，在多处理器环境下这是不能够被接受的，本质上，用户线程只解决了并发问题，但是没有解决并行问题。如果线程因为 I/O 操作陷入了内核态，内核态线程阻塞等待 I/O 数据，则所有的线程都将会被阻塞，用户空间也可以使用非阻塞而 I/O，但是不能避免性能及复杂度问题。</li></ul> <h4 id="_1-3-两级线程模型"><a href="#_1-3-两级线程模型" class="header-anchor">#</a> 1.3 两级线程模型</h4> <blockquote><p>用户线程与 KSE 是多对多关系（M:N）。</p></blockquote> <p>这种实现综合了前两种模型的优点，为一个进程中创建多个 KSE，并且线程可以与不同的 KSE 在运行时进行动态关联，当某个 KSE 由于其上工作的线程的阻塞操作被内核调度出 CPU 时，当前与其关联的其余用户线程可以重新与其他 KSE 建立关联关系。当然这种动态关联机制的实现很复杂，也需要用户自己去实现，这算是它的一个缺点吧。</p> <p><strong>Go 语言中的并发就是使用的这种实现方式</strong>，Go 为了实现该模型自己实现了一个<strong>运行时调度器</strong>来负责 Go 中的&quot;线程&quot;与 KSE 的动态关联。</p> <p>此模型有时也被称为 <strong>混合型线程模型</strong>，<strong>即用户调度器实现用户线程到 KSE 的“调度”，内核调度器实现 KSE 到 CPU 上的调度</strong>。</p> <img src="https://tva1.sinaimg.cn/large/008i3skNly1gsnioow0xsj30v00m0wfh.jpg" alt="img" style="zoom:50%;"> <h3 id="_2-go-并发模型-gpm-模型"><a href="#_2-go-并发模型-gpm-模型" class="header-anchor">#</a> 2. Go 并发模型 —— GPM 模型</h3> <p>在操作系统提供的内核线程之上，Go 搭建了一个特有的两级线程模型。</p> <p>Goroutine 机制实现了 M : N 的线程模型，Goroutine 机制是协程（coroutine）的一种实现，Go 内置的调度器，可以让多核 CPU 中每个 CPU 执行一个协程。</p> <h4 id="_2-1-调度器是如何工作的"><a href="#_2-1-调度器是如何工作的" class="header-anchor">#</a> 2.1 调度器是如何工作的</h4> <p>有了上面的知识，我们可以开始真正的介绍 Go 的并发机制了，先用一段代码展示一下在 Go 语言中新建一个 Goroutine：</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token comment">// 用go关键字加上一个函数（这里用了匿名函数）</span>
<span class="token comment">// 调用就做到了在一个新的“线程”并发执行任务</span>
<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token comment">// do something in one new goroutine</span>
<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>功能上等价于 Java8 的代码：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">new</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span>Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span> 
    <span class="token comment">// do something in one new thread</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>理解 Goroutine 机制的原理，关键是理解 Go 调度器 scheduler 的实现。</p> <p>Go 语言中支撑整个 scheduler 实现的主要有 4 个重要结构，分别是 M、G、P、Sched， 前三个定义在 runtime.h 中，Sched 定义在 proc.c 中。</p> <table><thead><tr><th>代号</th> <th>名称</th> <th>定义位置</th> <th>作用</th></tr></thead> <tbody><tr><td>Sched</td> <td>调度器</td> <td>proc.c</td> <td>维护有存储 M 和 G 的队列以及调度器的一些状态信息等。</td></tr> <tr><td>M</td> <td>Machine<br>系统线程</td> <td>runtime.h</td> <td>它由操作系统管理的，Goroutine就是跑在 M 之上的；M 是一个很大的结构，里面维护小对象内存 cache（mcache）、当前执行的 Goroutine、随机数发生器等等非常多的信息。</td></tr> <tr><td>P</td> <td>Processor<br>处理器</td> <td>runtime.h</td> <td>它的主要用途就是用来执行 Goroutine 的，它维护了一个 Goroutine 队列，即 runqueue。Processor 是让我们从 N:1 调度到 M:N 调度的重要部分。</td></tr> <tr><td>G</td> <td>Goroutine 实现的核心结构</td> <td>runtime.h</td> <td>它包含了栈，指令指针，以及其他对调度 Goroutine 很重要的信息，例如其阻塞的 channel。</td></tr></tbody></table> <blockquote><p>Processor 的数量是在启动时被设置为环境变量 <code>GOMAXPROCS</code> 的值，或者通过运行时调用函数 <code>GOMAXPROCS()</code> 进行设置。</p> <p>Processor 数量固定意味着任意时刻只有 GOMAXPROCS 个线程在运行 Go 代码。</p></blockquote> <p>我们分别用三角形，矩形和圆形表示 Machine、Processor 和 Goroutine。</p> <p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gsnizo5rlcj31d00gijrn.jpg" alt="image-20210720170700064"></p> <p>单核处理器的场景下：</p> <ul><li>所有 Goroutine 运行在同一个 M 系统线程中，每一个 M 系统线程维护一个 Processor，任何时刻，一个 Processor 中只有一个 Goroutine，其他 Goroutine 在 runqueue 中等待。一个 Goroutine 运行完自己的时间片后，让出上下文，回到 runqueue 中。</li></ul> <p>多核处理器的场景下：</p> <ul><li>为了运行 Goroutines，每个 M 系统线程会持有一个 Processor。</li></ul> <h4 id="_2-2-线程阻塞"><a href="#_2-2-线程阻塞" class="header-anchor">#</a> 2.2 线程阻塞</h4> <ul><li><p>正常情况下：</p> <p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gsnj1grjn9j31vo0mwwfi.jpg" alt="image-20210720170843613"></p> <p>在正常情况下，scheduler 会按照上面的流程进行调度，但是线程会发生阻塞等情况，下面来看一下 Goroutine 对线程阻塞等的处理。</p></li> <li><p>线程阻塞下：</p> <p>当正在运行的 Goroutine 阻塞的时候，例如进行系统调用，会<strong>再创建一个系统线程（M1）</strong>，当前的 M 线程放弃了它的 Processor，Processor 会转到新的线程 M1 中去运行。</p> <p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsnj3i8wmdj31lw0qgjsh.jpg" alt="image-20210720171040810"></p></li></ul> <h4 id="_2-3-runqueue-执行完成"><a href="#_2-3-runqueue-执行完成" class="header-anchor">#</a> 2.3 runqueue 执行完成</h4> <p>当其中一个 Processor 的 runqueue 为空，没有 Goroutine 可以调度。<strong>它会从另外一个上下文偷取一半的 Goroutine</strong>。</p> <p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsnj5n6e56j31ls0u0gmv.jpg" alt="image-20210720171242658"></p> <h4 id="_2-4-为什么需要-processor"><a href="#_2-4-为什么需要-processor" class="header-anchor">#</a> 2.4 为什么需要 Processor</h4> <blockquote><p>其图中的 G，P 和 M 都是 Go 语言运行时系统（其中包括内存分配器，并发调度器，垃圾收集器等组件，可以想象为 Java 中的JVM）抽象出来概念和数据结构对象：</p> <ul><li><p>G：Goroutine 的简称</p> <p>上面用 go 关键字加函数调用的代码就是创建了一个 G 对象，是对一个要并发执行的任务的封装，也可以称作用户态线程。属于用户级资源，对 OS 透明，具备轻量级，可以大量创建，上下文切换成本低等特点。</p></li> <li><p>M：Machine 的简称</p> <p>在 Linux 平台上是用 clone 系统调用创建的，其与用 Linux pthread 库创建出来的线程本质上是一样的，都是利用系统调用创建出来的 OS 线程实体。
M 的作用就是执行 G 中包装的并发任务。<strong>Go 运行时系统中的调度器的主要职责就是将 G 公平合理的安排到多个 M 上去执行</strong>。其属于 OS 资源，可创建的数量上也受限了 OS，通常情况下 G 的数量都多于活跃的 M 的。</p></li> <li><p>P：Processor 的简称</p> <p>逻辑处理器，主要作用是管理 G 对象（每个 P 都有一个 G 队列），并为 G 在 M 上的运行提供本地化资源。</p></li></ul></blockquote> <p>从两级线程模型来看，似乎并不需要 P 的参与，有 G 和 M 就可以了，那为什么要加入 P 呢？</p> <p>其实 Go 语言运行时系统早期（Go1.0）的实现中并没有 P 的概念，Go 中的调度器直接将 G 分配到合适的 M 上运行。但这样带来了很多问题：</p> <ul><li>例如，不同的 G 在不同的 M 上并发运行时可能都需向系统申请资源（如堆内存），由于资源是全局的，将会由于资源竞争造成很多系统性能损耗。</li></ul> <p>为了解决类似的问题，后面的 Go（Go1.1）运行时系统加入了 P，让 P 去管理 G 对象，M 要想运行 G 必须先与一个 P 绑定，然后才能运行该 P 管理的 G。这样带来的好处是：</p> <ul><li>我们可以在 P 对象中预先申请一些系统资源（本地资源），G 需要的时候先向自己的本地 P 申请（无需锁保护），如果不够用或没有再向全局申请，而且从全局拿的时候会多拿一部分，以供后面高效的使用。就像现在我们去政府办事情一样，先去本地政府看能搞定不，如果搞不定再去中央，从而提供办事效率。</li> <li>而且由于  P 解耦了 G 和 M 对象，这样即使 M 由于被其上正在运行的 G 阻塞住，其余与该 M 关联的 G 也可以随着 P 一起迁移到别的活跃的 M 上继续运行，从而让 G 总能及时找到 M 并运行自己，从而提高系统的并发能力。</li></ul> <p>Go 运行时系统通过构造 G-P-M 对象模型实现了一套用户态的并发调度系统，可以自己管理和调度自己的并发任务，所以可以说 Go 语言 <strong>原生支持并发</strong>。<strong>自己实现的调度器负责将并发任务分配到不同的内核线程上运行，然后内核调度器接管内核线程在 CPU 上的执行与调度。</strong></p> <h4 id="_2-5-总结"><a href="#_2-5-总结" class="header-anchor">#</a> 2.5 总结</h4> <p>可以看到 Go 的并发用起来非常简单，用了一个语法糖将内部复杂的实现结结实实的包装了起来。其内部可以用下面这张图来概述：</p> <p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gsnjc0wq5sj30w60u0go5.jpg" alt="img"></p> <h4 id="_2-6-深究"><a href="#_2-6-深究" class="header-anchor">#</a> 2.6 深究</h4> <div class="language-go extra-class"><pre class="language-go"><code><span class="token comment">// Goroutine1</span>
<span class="token keyword">func</span> <span class="token function">task1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">go</span> <span class="token function">task2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">go</span> <span class="token function">task3</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>假如我们有一个 G（Goroutine1）已经通过 P 被安排到了一个 M 上正在执行，在 Goroutine1 执行的过程中我们又创建两个 G，这两个 G 会被马上放入与 Goroutine1 相同的 P 的本地 G 任务队列中，排队等待与该 P 绑定的 M 的执行，这是最基本的结构，很好理解。 关键问题是：</p> <ol><li><p><strong>如何在一个多核心系统上尽量合理分配 G 到多个 M 上运行，充分利用多核，提高并发能力呢？</strong></p> <blockquote><p>如果我们在一个 Goroutine 中通过 <strong>go</strong> 关键字创建了大量 G，这些 G 虽然暂时会被放在同一个队列, 但如果这时还有空闲 P（系统内 P 的数量默认等于系统 CPU 核心数），Go 运行时系统始终能保证至少有一个（通常也只有一个）活跃的 M 与空闲 P 绑定去各种 G 队列去寻找可运行的G任务，该种M称为 <strong>自旋的 M</strong>。</p> <p>一般寻找顺序为：</p> <ol><li>自己绑定的 P 的队列</li> <li>全局队列</li> <li>其他 P 队列</li></ol> <p>如果自己 P 队列找到就拿出来开始运行，否则去全局队列看看，由于全局队列需要锁保护，如果里面有很多任务，会转移一批到本地 P 队列中，避免每次都去竞争锁。如果全局队列还是没有，就直接从其他 P 队列偷任务了（偷一半任务回来）。这样就保证了在还有可运行的 G 任务的情况下，总有与 CPU 核心数相等的 M+P 组合在执行 G 任务或在执行 G 的路上（寻找 G 任务）。</p></blockquote></li> <li><p><strong>如果某个 M 在执行 G 的过程中被 G 中的系统调用阻塞了，怎么办？</strong></p> <blockquote><p>在这种情况下，这个 M 将会被内核调度器调度出 CPU 并处于阻塞状态，与该 M 关联的其他 G 就没有办法继续执行了，但 Go 运行时系统的一个监控线程（<strong>sysmon</strong>线程）能探测到这样的 M，并把与该 M 绑定的 P 剥离，寻找其他空闲或新建 M 接管该 P，然后继续运行其中的 G，大致过程如下图所示：</p> <p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gsnji9n2ooj31lw0qgmy9.jpg" alt="image-20210720171040810"></p> <p>然后等到该 M 从阻塞状态恢复，需要重新找一个空闲 P 来继续执行原来的 G，如果这时系统正好没有空闲的 P，就把原来的 G 放到全局队列当中，等待其他 M+P 组合发掘并执行。</p></blockquote></li> <li><p><strong>如果某一个 G 在 M 运行时间过长，有没有办法做抢占式调度，让该 M 上的其他 G 获得一定的运行时间，以保证调度系统的公平性?</strong></p> <blockquote><p>我们知道 Linux 的内核调度器主要是基于 <strong>时间片</strong> 和 <strong>优先级</strong> 做调度的。对于相同优先级的线程，内核调度器会尽量保证每个线程都能获得一定的执行时间。为了防止有些线程&quot;饿死&quot;的情况，内核调度器会发起抢占式调度将长期运行的线程中断并让出 CPU 资源，让其他线程获得执行机会。</p> <p>当然在 Go 的运行时调度器中也有类似的抢占机制，但并不能保证抢占能成功，因为 Go 运行时系统并没有内核调度器的中断能力，它只能通过向运行时间过长的 G 中设置抢占 flag 的方法温柔的让运行的 G 自己主动让出 M 的执行权。</p> <p>说到这里就不得不提一下 Goroutine 在运行过程中可以动态扩展自己线程栈的能力，可以从初始的 2KB 大小扩展到最大 1G（64bit 系统上），因此在每次调用函数之前需要先计算该函数调用需要的栈空间大小，然后按需扩展（超过最大值将导致运行时异常）。Go 抢占式调度的机制就是利用在判断要不要扩栈的时候顺便查看以下自己的抢占 flag，决定是否继续执行，还是让出自己。</p> <p>运行时系统的监控线程会计时并设置抢占 flag 到运行时间过长的 G，然后 G 在有函数调用的时候会检查该抢占 flag，如果已设置就将自己放入全局队列，这样该 M 上关联的其他 G 就有机会执行了。但如果正在执行的 G 是个很耗时的操作且没有任何函数调用（如只是 for 循环中的计算操作），即使抢占 flag 已经被设置，该 G 还是将一直霸占着当前 M 直到执行完自己的任务。</p></blockquote></li></ol> <h3 id="_3-runtime-包"><a href="#_3-runtime-包" class="header-anchor">#</a> 3. runtime 包</h3> <ul><li>参见：<a href="../standard_packages/runtime">Golang 标准库丨runtime 包</a></li></ul> <blockquote><p>参考：</p> <ul><li>https://studygolang.com/articles/11322?fr=sidebar</li> <li>https://www.cnblogs.com/williamjie/p/9456764.html</li></ul></blockquote> <h2 id="四、临界资源安全问题"><a href="#四、临界资源安全问题" class="header-anchor">#</a> 四、临界资源安全问题</h2> <h3 id="_1-临界资源"><a href="#_1-临界资源" class="header-anchor">#</a> 1. 临界资源</h3> <blockquote><p><strong>临界资源</strong>：指并发环境中多个进程/线程/协程共享的资源。</p></blockquote> <p>在并发编程中对临界资源的处理不当， 往往会导致数据不一致的问题。</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">&quot;fmt&quot;</span>
	<span class="token string">&quot;time&quot;</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	a <span class="token operator">:=</span> <span class="token number">1</span>
	<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		a <span class="token operator">=</span> <span class="token number">2</span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;Goroutine, a:&quot;</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span>
	<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	a <span class="token operator">=</span> <span class="token number">3</span>
	time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;main, a:&quot;</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们使用 <code>-race</code> 这个可选项来检查是否有临界资源：</p> <div class="language-sh extra-class"><pre class="language-sh"><code>go run -race demo1.go
</code></pre></div><p>输出：</p> <div class="language- extra-class"><pre class="language-text"><code>==================
WARNING: DATA RACE
Write at 0x00c0000180e0 by goroutine 7:
  main.main.func1()
      /Users/bytedance/go/src/baiscstudy/learning/shareData/demo1/demo1.go:11 +0x3c

Previous write at 0x00c0000180e0 by main goroutine:
  main.main()
      /Users/bytedance/go/src/baiscstudy/learning/shareData/demo1/demo1.go:15 +0x88

Goroutine 7 (running) created at:
  main.main()
      /Users/bytedance/go/src/baiscstudy/learning/shareData/demo1/demo1.go:10 +0x7a
==================
Goroutine, a: 2
main, a: 2
Found 1 data race(s)
exit status 66
</code></pre></div><p>能够发现有一个数据被多个 Goroutine 共享。</p> <h3 id="_2-临界资源安全问题"><a href="#_2-临界资源安全问题" class="header-anchor">#</a> 2. 临界资源安全问题</h3> <p>并发本身并不复杂，但是因为有了资源竞争的问题，就使得我们开发出好的并发程序变得复杂起来，因为会引起很多莫名其妙的问题。</p> <p>如果多个 Goroutine 在访问同一个数据资源的时候，其中一个线程修改了数据，那么这个数值就被修改了，对于其他的 Goroutine 来讲，这个数值可能是不对的。</p> <p>示例：并发实现火车站售票程序，一共有 10 张票，4 个售票口同时出售。</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">&quot;fmt&quot;</span>
	<span class="token string">&quot;go/src/math/rand&quot;</span>
	<span class="token string">&quot;time&quot;</span>
<span class="token punctuation">)</span>

<span class="token comment">// 全局变量</span>
<span class="token keyword">var</span> ticket <span class="token operator">=</span> <span class="token number">10</span> <span class="token comment">//10 张票</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

	<span class="token comment">// 4 个 Goroutine，代表 4 个售票窗口，它们会操作同一个变量 ticket</span>
	<span class="token keyword">go</span> <span class="token function">saleTicket</span><span class="token punctuation">(</span><span class="token string">&quot;售票口1&quot;</span><span class="token punctuation">)</span>
	<span class="token keyword">go</span> <span class="token function">saleTicket</span><span class="token punctuation">(</span><span class="token string">&quot;售票口2&quot;</span><span class="token punctuation">)</span>
	<span class="token keyword">go</span> <span class="token function">saleTicket</span><span class="token punctuation">(</span><span class="token string">&quot;售票口3&quot;</span><span class="token punctuation">)</span>
	<span class="token keyword">go</span> <span class="token function">saleTicket</span><span class="token punctuation">(</span><span class="token string">&quot;售票口4&quot;</span><span class="token punctuation">)</span>

	<span class="token comment">// 主 Goroutine 睡眠，确保子 Goroutine 可以运行结束</span>
	time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">5</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">saleTicket</span><span class="token punctuation">(</span>name <span class="token builtin">string</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>
	rand<span class="token punctuation">.</span><span class="token function">Seed</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">UnixNano</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token keyword">for</span><span class="token punctuation">{</span>
		<span class="token keyword">if</span> ticket <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token punctuation">{</span>
			<span class="token comment">// 睡眠，增大错误发生的概率</span>
			time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span><span class="token function">Duration</span><span class="token punctuation">(</span>rand<span class="token punctuation">.</span><span class="token function">Intn</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Millisecond<span class="token punctuation">)</span>
			<span class="token comment">// 售票</span>
			fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token string">&quot;售出：&quot;</span><span class="token punctuation">,</span> ticket<span class="token punctuation">)</span>
			<span class="token comment">// 减票</span>
			ticket <span class="token operator">--</span>
		<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
			fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token string">&quot;售罄，没票了...&quot;</span><span class="token punctuation">)</span>
			<span class="token keyword">break</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>输出：</p> <div class="language- extra-class"><pre class="language-text"><code>售票口1 售出： 10
售票口2 售出： 9
售票口2 售出： 8
售票口2 售出： 7
售票口2 售出： 6
售票口3 售出： 5
售票口4 售出： 4
售票口3 售出： 3
售票口1 售出： 2
售票口3 售出： 1
售票口3 售罄，没票了...
售票口1 售出： 0
售票口1 售罄，没票了...
售票口2 售出： -1
售票口2 售罄，没票了...
售票口4 售出： -2
售票口4 售罄，没票了...
</code></pre></div><p>我们发现居然有卖出票号为负数的票，这就是临界资源带来的问题。</p> <h3 id="_3-解决临界资源问题"><a href="#_3-解决临界资源问题" class="header-anchor">#</a> 3. 解决临界资源问题</h3> <p>要想解决临界资源安全的问题，很多编程语言的解决方案都是同步。通过上锁的方式，某一时间段，只能允许一个 Goroutine 来访问这个共享数据，当前 Goroutine 访问完毕，解锁后，其他的 Goroutine 才能来访问。</p> <p><strong>[法一] 上锁</strong></p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">&quot;fmt&quot;</span>
	<span class="token string">&quot;go/src/math/rand&quot;</span>
	<span class="token string">&quot;sync&quot;</span>
	<span class="token string">&quot;time&quot;</span>
<span class="token punctuation">)</span>

<span class="token comment">// 全局变量</span>
<span class="token keyword">var</span> ticket <span class="token operator">=</span> <span class="token number">10</span> <span class="token comment">//10 张票</span>

<span class="token comment">// 锁</span>
<span class="token keyword">var</span> waitGroup sync<span class="token punctuation">.</span>WaitGroup
<span class="token keyword">var</span> mutex sync<span class="token punctuation">.</span>Mutex

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

	<span class="token comment">// 4 个 Goroutine，代表 4 个售票窗口，它们会操作同一个变量 ticket</span>

	<span class="token comment">// 阻塞主 Goroutine，需要 4 个协程调用 waitGroup.Done()，主 Goroutine 才能进行</span>
	waitGroup<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>
	<span class="token keyword">go</span> <span class="token function">saleTicket</span><span class="token punctuation">(</span><span class="token string">&quot;售票口1&quot;</span><span class="token punctuation">)</span>
	<span class="token keyword">go</span> <span class="token function">saleTicket</span><span class="token punctuation">(</span><span class="token string">&quot;售票口2&quot;</span><span class="token punctuation">)</span>
	<span class="token keyword">go</span> <span class="token function">saleTicket</span><span class="token punctuation">(</span><span class="token string">&quot;售票口3&quot;</span><span class="token punctuation">)</span>
	<span class="token keyword">go</span> <span class="token function">saleTicket</span><span class="token punctuation">(</span><span class="token string">&quot;售票口4&quot;</span><span class="token punctuation">)</span>
	<span class="token comment">// 阻塞主 Goroutine，等待 4 个协程调用 waitGroup.Done()</span>
	waitGroup<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">saleTicket</span><span class="token punctuation">(</span>name <span class="token builtin">string</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>
	rand<span class="token punctuation">.</span><span class="token function">Seed</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">UnixNano</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token comment">// 调用 waitGroup.Done()，4 个协程都调用后主 Goroutine 就可以继续执行了</span>
	<span class="token keyword">defer</span> waitGroup<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">for</span><span class="token punctuation">{</span>
		<span class="token comment">// 上锁</span>
		mutex<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token keyword">if</span> ticket <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token punctuation">{</span>
			<span class="token comment">// 睡眠，增大错误发生的概率</span>
			time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span><span class="token function">Duration</span><span class="token punctuation">(</span>rand<span class="token punctuation">.</span><span class="token function">Intn</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Millisecond<span class="token punctuation">)</span>
			<span class="token comment">// 售票</span>
			fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token string">&quot;售出：&quot;</span><span class="token punctuation">,</span> ticket<span class="token punctuation">)</span>
			<span class="token comment">// 减票</span>
			ticket <span class="token operator">--</span>
		<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
			<span class="token comment">// 解锁</span>
			mutex<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
			fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token string">&quot;售罄，没票了...&quot;</span><span class="token punctuation">)</span>
			<span class="token keyword">break</span>
		<span class="token punctuation">}</span>
		<span class="token comment">// 解锁</span>
		mutex<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>输出：</p> <div class="language- extra-class"><pre class="language-text"><code>售票口4 售出： 10
售票口4 售出： 9
售票口3 售出： 8
售票口1 售出： 7
售票口2 售出： 6
售票口4 售出： 5
售票口3 售出： 4
售票口1 售出： 3
售票口2 售出： 2
售票口4 售出： 1
售票口2 售罄，没票了...
售票口1 售罄，没票了...
售票口4 售罄，没票了...
售票口3 售罄，没票了...
</code></pre></div><p><strong>[法二] channel</strong></p> <p>在 Go 的并发编程中有一句很经典的话： <strong>不要以共享内存的方式去通信，而要以通信的方式去共享内存</strong>。</p> <p>在 Go 语言中并不鼓励用锁保护共享状态的方式在不同的 Goroutine 中分享信息（以共享内存的方式去通信）。而是鼓励通过 <strong>channel</strong> 将共享状态或共享状态的变化在各个 Goroutine 之间传递（以通信的方式去共享内存），这样同样能像用锁一样保证在同一的时间只有一个 Goroutine 访问共享状态。</p> <p>当然，在主流的编程语言中为了保证多线程之间共享数据安全性和一致性，都会提供一套基本的同步工具集，如锁，条件变量，原子操作等等。Go 语言标准库也毫不意外的提供了这些同步机制，使用方式也和其他语言也差不多。</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">&quot;fmt&quot;</span>
	<span class="token string">&quot;go/src/math/rand&quot;</span>
	<span class="token string">&quot;time&quot;</span>
<span class="token punctuation">)</span>




<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

	<span class="token keyword">var</span> ticket <span class="token operator">=</span> <span class="token number">10</span> <span class="token comment">//10 张票</span>
	<span class="token keyword">var</span> ticketChan <span class="token keyword">chan</span> <span class="token builtin">int</span>

	ticketChan <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>
	<span class="token comment">// 4 个 Goroutine，代表 4 个售票窗口，它们会操作同一个变量 ticket</span>
	<span class="token keyword">go</span> <span class="token function">saleTicket</span><span class="token punctuation">(</span><span class="token string">&quot;售票口1&quot;</span><span class="token punctuation">,</span> ticketChan<span class="token punctuation">)</span>
	<span class="token keyword">go</span> <span class="token function">saleTicket</span><span class="token punctuation">(</span><span class="token string">&quot;售票口2&quot;</span><span class="token punctuation">,</span> ticketChan<span class="token punctuation">)</span>
	<span class="token keyword">go</span> <span class="token function">saleTicket</span><span class="token punctuation">(</span><span class="token string">&quot;售票口3&quot;</span><span class="token punctuation">,</span> ticketChan<span class="token punctuation">)</span>
	<span class="token keyword">go</span> <span class="token function">saleTicket</span><span class="token punctuation">(</span><span class="token string">&quot;售票口4&quot;</span><span class="token punctuation">,</span> ticketChan<span class="token punctuation">)</span>

	<span class="token comment">// 提供 ticket</span>
	<span class="token keyword">for</span> i <span class="token operator">:=</span> ticket<span class="token punctuation">;</span> i <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span> <span class="token punctuation">{</span>
		ticketChan <span class="token operator">&lt;-</span> i
	<span class="token punctuation">}</span>

	time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">10</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">saleTicket</span><span class="token punctuation">(</span>name <span class="token builtin">string</span><span class="token punctuation">,</span> ticketChan <span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>
	rand<span class="token punctuation">.</span><span class="token function">Seed</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">UnixNano</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token keyword">for</span><span class="token punctuation">{</span>
		<span class="token comment">// 拿票</span>
		ticket <span class="token operator">:=</span> <span class="token operator">&lt;-</span> ticketChan
		<span class="token keyword">if</span> ticket <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token punctuation">{</span>
			<span class="token comment">// 睡眠，增大错误发生的概率</span>
			time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span><span class="token function">Duration</span><span class="token punctuation">(</span>rand<span class="token punctuation">.</span><span class="token function">Intn</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Millisecond<span class="token punctuation">)</span>
			<span class="token comment">// 售票</span>
			fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token string">&quot;售出：&quot;</span><span class="token punctuation">,</span> ticket<span class="token punctuation">)</span>
			<span class="token comment">// 减票</span>
			ticket <span class="token operator">--</span>
		<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
			fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token string">&quot;售罄，没票了...&quot;</span><span class="token punctuation">)</span>
			<span class="token keyword">break</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>输出：</p> <div class="language- extra-class"><pre class="language-text"><code>售票口2 售出： 9
售票口4 售出： 10
售票口4 售出： 4
售票口1 售出： 7
售票口4 售出： 3
售票口4 售出： 1
售票口3 售出： 6
售票口2 售出： 5
售票口1 售出： 2
</code></pre></div><h3 id="_4-sync-包"><a href="#_4-sync-包" class="header-anchor">#</a> 4. sync 包</h3> <ul><li>参见：<a href="/noteSite/backend/golang/standard_packages/sync.html">Golang 标准库丨sync 包</a></li></ul> <h2 id="五、channel-通道"><a href="#五、channel-通道" class="header-anchor">#</a> 五、channel 通道</h2> <div class="custom-block tip"><p class="custom-block-title">RECOMMEND</p> <p>Don't communicate by sharing memory; share memory by communicating.</p> <p>不要通过共享内存来通信，应该通过通信来共享内存。</p></div> <p>在前面讲 Go 语言的并发时候，我们就说过，当多个 Goroutine 想实现共享数据的时候，虽然也提供了传统的同步机制，但是 Go 语言强烈建议的是使用 channel 通道来实现 Goroutines 之间的通信。</p> <p>Go 语言中，要传递某个数据给另一个 Goroutine，可以把这个数据封装成一个对象，然后把这个对象的指针传入某个 channel 中，另外一个 Goroutine 从这个 channel 中读出这个指针，并处理其指向的内存对象。Go 从语言层面保证同一个时间只有一个 Goroutine 能够访问 channel 里面的数据，为开发者提供了一种优雅简单的工具，所以 Go 的做法就是使用 channel 来通信，通过通信来传递内存数据，使得内存数据在不同的 Goroutine 中传递，而不是使用共享内存来通信。</p> <h3 id="_1-通道的概念"><a href="#_1-通道的概念" class="header-anchor">#</a> 1. 通道的概念</h3> <p>通道可以被认为是 Goroutines 通信的管道。类似于管道中的水从一端到另一端的流动，数据可以从一端发送到另一端，通过通道接收。</p> <p>每个通道都有与其相关的类型。该类型是通道允许传输的数据类型。(通道的零值为 nil。nil 通道没有任何用处，因此通道必须使用类似于 map 和切片的方法来定义，也就是 make）</p> <h3 id="_2-通道的声明"><a href="#_2-通道的声明" class="header-anchor">#</a> 2. 通道的声明</h3> <div class="language-go extra-class"><pre class="language-go"><code><span class="token comment">// 声明通道</span>
<span class="token keyword">var</span> 通道名 <span class="token keyword">chan</span> 数据类型
<span class="token comment">// 创建通道</span>
通道名 <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> 数据类型 <span class="token punctuation">[</span><span class="token punctuation">,</span> 缓冲区大小<span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre></div><p>示例：</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">&quot;fmt&quot;</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> a <span class="token keyword">chan</span> <span class="token builtin">int</span>
    <span class="token keyword">if</span> a <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;channel 是 nil 的, 不能使用，需要先创建通道。。&quot;</span><span class="token punctuation">)</span>
        a <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>
        fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">&quot;数据类型是： %T&quot;</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="_3-通道的语法"><a href="#_3-通道的语法" class="header-anchor">#</a> 3. 通道的语法</h3> <ul><li><p>接收</p> <div class="language-go extra-class"><pre class="language-go"><code>data<span class="token punctuation">,</span> ok <span class="token operator">:=</span> <span class="token operator">&lt;-</span> channel

</code></pre></div></li> <li><p>发送</p> <div class="language-go extra-class"><pre class="language-go"><code>channel <span class="token operator">&lt;-</span> data
</code></pre></div></li> <li><p>创建双向通道</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token comment">// 双向通道</span>
<span class="token keyword">chan</span> <span class="token builtin">int</span>
<span class="token comment">// 只写通道</span>
<span class="token keyword">chan</span> <span class="token operator">&lt;-</span> <span class="token builtin">int</span>
<span class="token comment">// 只读通道</span>
<span class="token operator">&lt;-</span> <span class="token keyword">chan</span> <span class="token builtin">int</span>
</code></pre></div></li></ul> <h3 id="_4-通道注意点"><a href="#_4-通道注意点" class="header-anchor">#</a> 4. 通道注意点</h3> <p>channel 在使用的时候，有以下几个注意点：</p> <ol><li>channel 是用于 Goroutine 之间传递消息的</li> <li>每个 channel 都有相关联的数据类型，nil chan 是不能使用，类似于nil map，不能直接存储键值对</li> <li>使用通道传递数据：&lt;-
<ul><li>chan &lt;- data：向通道中写数据</li> <li>data &lt;- chan：从通道中读数据</li></ul></li> <li>阻塞
<ul><li>发送数据：chan &lt;- data 是阻塞的，直到另一个 Goroutine 读取数据来解除阻塞</li> <li>读取数据：data &lt;- chan 也是阻塞的，直到另一个 Goroutine 写出数据解除阻塞</li> <li>可以通过在 make 的时候设置缓冲区来避免阻塞</li></ul></li> <li>channel 本身就是同步的，意味着同一时间，只能有一个 Goroutine 来操作 channel</li> <li>channel 是 Goroutine 之间的连接，所以通道的发送和接收必须处在不同的 Goroutine 中</li></ol> <h3 id="_5-通道的阻塞"><a href="#_5-通道的阻塞" class="header-anchor">#</a> 5. 通道的阻塞</h3> <p><strong>5.1 发送和接收默认是阻塞的</strong></p> <p>一个通道发送和接收数据，默认是阻塞的。当一个数据被发送到通道时，在发送语句中被阻塞，直到另一个 Goroutine 从该通道读取数据。相对地，当从通道读取数据时，读取被阻塞，直到一个 Goroutine 将数据写入该通道。</p> <p>这些通道的特性是帮助 Goroutines 有效地进行通信，而无需像使用其他编程语言中非常常见的显式锁或条件变量。</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">&quot;fmt&quot;</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

	<span class="token comment">// 创建一个 channel</span>
	ch1 <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">bool</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;ch1:&quot;</span><span class="token punctuation">,</span> ch1<span class="token punctuation">)</span>

	<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
			fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;子 Goroutine 中，i:&quot;</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
		<span class="token comment">// 循环结束后，向 channel 中写数据，表示要结束了</span>
		ch1 <span class="token operator">&lt;-</span> <span class="token boolean">true</span>

		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;子 Goroutine 结束...&quot;</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	<span class="token comment">// 从 ch1 通道中读取数据</span>
	<span class="token comment">// 再子 Goroutine 写数据之前，主 Goroutine 是会被阻塞的</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;主 Goroutine 被阻塞..&quot;</span><span class="token punctuation">)</span>
	data <span class="token operator">:=</span> <span class="token operator">&lt;-</span> ch1
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;主 Goroutine 拿到数据了，data:&quot;</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span>

<span class="token punctuation">}</span>
</code></pre></div><p>输出：</p> <div class="language- extra-class"><pre class="language-text"><code>ch1: 0xc00008c060
主 Goroutine 被阻塞..
子 Goroutine 中，i: 0
子 Goroutine 中，i: 1
子 Goroutine 中，i: 2
子 Goroutine 中，i: 3
子 Goroutine 中，i: 4
子 Goroutine 中，i: 5
子 Goroutine 中，i: 6
子 Goroutine 中，i: 7
子 Goroutine 中，i: 8
子 Goroutine 中，i: 9
子 Goroutine 结束...
主 Goroutine 拿到数据了，data: true
</code></pre></div><p><strong>5.2 可以通过设置缓冲区来避免阻塞</strong></p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">&quot;fmt&quot;</span>
	<span class="token string">&quot;time&quot;</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

	<span class="token comment">// 创建一个 channel，待缓冲区，写满 5 个之前不会阻塞</span>
	ch1 <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;ch1:&quot;</span><span class="token punctuation">,</span> ch1<span class="token punctuation">)</span>

	<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>
		<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
			data <span class="token operator">:=</span> <span class="token operator">&lt;-</span> ch1
			fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;子 Goroutine 拿数据，i:&quot;</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;子 Goroutine 结束...&quot;</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;主 Goroutine 写数据，i:&quot;</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span>
		ch1 <span class="token operator">&lt;-</span> i
	<span class="token punctuation">}</span>

	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;主 Goroutine 结束...&quot;</span><span class="token punctuation">)</span>

	time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>

<span class="token punctuation">}</span>
</code></pre></div><p>输出：</p> <div class="language-sh extra-class"><pre class="language-sh"><code>ch1: 0xc00012c000
主 Goroutine 写数据，i: <span class="token number">0</span>
主 Goroutine 写数据，i: <span class="token number">1</span>
主 Goroutine 写数据，i: <span class="token number">2</span>
主 Goroutine 写数据，i: <span class="token number">3</span>
主 Goroutine 写数据，i: <span class="token number">4</span>
<span class="token comment"># 缓冲区满</span>
主 Goroutine 写数据，i: <span class="token number">5</span>
<span class="token comment"># 这里会停一下，因为缓冲区满了，会阻塞</span>
主 Goroutine 写数据，i: <span class="token number">6</span>
子 Goroutine 拿数据，i: <span class="token number">0</span>
子 Goroutine 拿数据，i: <span class="token number">1</span>
子 Goroutine 拿数据，i: <span class="token number">2</span>
子 Goroutine 拿数据，i: <span class="token number">3</span>
子 Goroutine 拿数据，i: <span class="token number">4</span>
子 Goroutine 拿数据，i: <span class="token number">5</span>
子 Goroutine 拿数据，i: <span class="token number">6</span>
主 Goroutine 写数据，i: <span class="token number">7</span>
主 Goroutine 写数据，i: <span class="token number">8</span>
主 Goroutine 写数据，i: <span class="token number">9</span>
主 Goroutine 结束<span class="token punctuation">..</span>.
子 Goroutine 拿数据，i: <span class="token number">7</span>
子 Goroutine 拿数据，i: <span class="token number">8</span>
子 Goroutine 拿数据，i: <span class="token number">9</span>
子 Goroutine 结束<span class="token punctuation">..</span>.
</code></pre></div><h3 id="_6-通道的死锁"><a href="#_6-通道的死锁" class="header-anchor">#</a> 6. 通道的死锁</h3> <p>使用通道时要考虑的一个重要因素是死锁：如果 Goroutine 在一个通道上发送数据，那么预计其他的 Goroutine 应该接收数据。如果这种情况不发生，那么程序将在运行时出现死锁。</p> <p>类似地，如果 Goroutine 正在等待从通道接收数据，那么另一些 Goroutine 将会在该通道上写入数据，否则程序将会死锁。</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">package</span> main

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>
	ch <span class="token operator">&lt;-</span> <span class="token number">5</span>
<span class="token punctuation">}</span>
</code></pre></div><p>输出：</p> <div class="language- extra-class"><pre class="language-text"><code>fatal error: all goroutines are asleep - deadlock!

goroutine 1 [chan send]:
main.main()
        /Users/bytedance/go/src/baiscstudy/learning/shareData/channel/channelTest.go:6 +0x50

Process finished with the exit code 2
</code></pre></div><h3 id="_7-通道的关闭"><a href="#_7-通道的关闭" class="header-anchor">#</a> 7. 通道的关闭</h3> <p>发送者可以通过关闭 channel，来通知接收方不会有更多的数据被发送到 channel 上：</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token function">close</span><span class="token punctuation">(</span>channel<span class="token punctuation">)</span>
</code></pre></div><p>接收者可以在接收来自通道的数据时使用额外的变量来检查 channel 是否已经关闭：</p> <div class="language-go extra-class"><pre class="language-go"><code>data<span class="token punctuation">,</span> ok <span class="token operator">:=</span> <span class="token operator">&lt;-</span> channel
</code></pre></div><p>在上面的语句中：</p> <ul><li>如果 ok 的值是 true，表示成功的从通道中读取了一个数据 data</li> <li>如果 ok 是 false，这意味着我们正在从一个封闭的通道读取数据，从闭通道读取的值将是通道类型的零值</li></ul> <h3 id="_8-通道的遍历"><a href="#_8-通道的遍历" class="header-anchor">#</a> 8. 通道的遍历</h3> <p>我们可以循环从通道上获取数据，直到通道关闭。for 循环的 <code>for range</code> 形式可用于从通道接收值，直到它关闭为止。</p> <p>示例代码：</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">&quot;fmt&quot;</span>
	<span class="token string">&quot;time&quot;</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

	ch1 <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>
	<span class="token keyword">go</span> <span class="token function">sendData</span><span class="token punctuation">(</span>ch1<span class="token punctuation">)</span>
	<span class="token comment">// for...range 从通道接收值，直到通道关闭</span>
	<span class="token keyword">for</span> v <span class="token operator">:=</span> <span class="token keyword">range</span> ch1 <span class="token punctuation">{</span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;从 channel 中收到数据：&quot;</span><span class="token punctuation">,</span> v<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;main over...&quot;</span><span class="token punctuation">)</span>

<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">sendData</span><span class="token punctuation">(</span>ch1 <span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>
	<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
		time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span> <span class="token number">1</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>
		ch1 <span class="token operator">&lt;-</span> i
	<span class="token punctuation">}</span>
	<span class="token comment">// 关闭通道</span>
	<span class="token function">close</span><span class="token punctuation">(</span>ch1<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>输出：</p> <div class="language- extra-class"><pre class="language-text"><code>从 channel 中收到数据： 0
从 channel 中收到数据： 1
从 channel 中收到数据： 2
从 channel 中收到数据： 3
从 channel 中收到数据： 4
从 channel 中收到数据： 5
从 channel 中收到数据： 6
从 channel 中收到数据： 7
从 channel 中收到数据： 8
从 channel 中收到数据： 9
main over...
</code></pre></div><h3 id="_9-通道的调度"><a href="#_9-通道的调度" class="header-anchor">#</a> 9. 通道的调度</h3> <p>select 是 Go 中的一个控制结构。select 语句类似于 switch 语句，但是 select 会 <strong>随机</strong> 执行一个可运行的 case。如果没有 case 可运行，它将阻塞，直到有 case 可运行。</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">select</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> num1 <span class="token operator">:=</span> <span class="token operator">&lt;-</span>ch1<span class="token punctuation">:</span>
    	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;ch1 中取数据。。&quot;</span><span class="token punctuation">,</span> num1<span class="token punctuation">)</span>
    <span class="token keyword">case</span> num2<span class="token punctuation">,</span> ok <span class="token operator">:=</span> <span class="token operator">&lt;-</span>ch2<span class="token punctuation">:</span>
      <span class="token keyword">if</span> ok <span class="token punctuation">{</span>
          fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;ch2 中取数据。。&quot;</span><span class="token punctuation">,</span> num2<span class="token punctuation">)</span>
      <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
          fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;ch2 通道已经关闭。。&quot;</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
		<span class="token keyword">default</span><span class="token punctuation">:</span>
          fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;没有收到数据&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="_10-通道与-time"><a href="#_10-通道与-time" class="header-anchor">#</a> 10. 通道与 time</h3> <p>标准库 time 包中与 channel 相关的主要是定时器 Timer，Timer 让用户可以定义自己的超时逻辑，尤其是在应对 select 处理多个 channel 的超时、单 channel 读写的超时等情形时尤为方便。</p> <p>Timer 是一次性的时间触发事件，这点与 Ticker 不同，Ticker 是按一定时间间隔持续触发时间事件。</p> <p>Timer 的常见创建方式：</p> <div class="language-go extra-class"><pre class="language-go"><code>t<span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">NewTimer</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span>
t<span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">AfterFunc</span><span class="token punctuation">(</span>d<span class="token punctuation">,</span> f<span class="token punctuation">)</span>
c<span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">After</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span>
</code></pre></div><p>虽然说创建方式不同，但是原理是相同的。</p> <p>Timer 有3个要素：</p> <ul><li>定时时间：d</li> <li>触发动作：f</li> <li>时间通道：t.C</li></ul> <p><strong>10.1 time.NewTimer(d)</strong></p> <p>NewTimer() 创建一个新的 Timer，它将在至少持续时间 d 之后在其通道上发送当前时间。</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token comment">// NewTimer creates a new Timer that will send</span>
<span class="token comment">// the current time on its channel after at least duration d.</span>
<span class="token keyword">func</span> <span class="token function">NewTimer</span><span class="token punctuation">(</span>d Duration<span class="token punctuation">)</span> <span class="token operator">*</span>Timer <span class="token punctuation">{</span>
  <span class="token comment">// 1. 创建一个 Time 类型的 channel</span>
	c <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> Time<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token comment">// 2. 传进一个定时器 Timer </span>
	t <span class="token operator">:=</span> <span class="token operator">&amp;</span>Timer<span class="token punctuation">{</span>
		C<span class="token punctuation">:</span> c<span class="token punctuation">,</span>   <span class="token comment">// channel</span>
		r<span class="token punctuation">:</span> runtimeTimer<span class="token punctuation">{</span>  
			when<span class="token punctuation">:</span> <span class="token function">when</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token comment">// 根据传入的 d 计算何时发送</span>
			f<span class="token punctuation">:</span>    sendTime<span class="token punctuation">,</span> <span class="token comment">// 发送当前时间</span>
			arg<span class="token punctuation">:</span>  c<span class="token punctuation">,</span>
		<span class="token punctuation">}</span><span class="token punctuation">,</span>
	<span class="token punctuation">}</span>
  <span class="token comment">// 3. 开始计时</span>
	<span class="token function">startTimer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t<span class="token punctuation">.</span>r<span class="token punctuation">)</span>
	<span class="token keyword">return</span> t
<span class="token punctuation">}</span>
</code></pre></div><ul><li>when 用于在指定的 Duration 类型时间后调用函数或计算表达式</li> <li>如果只是想指定时间之后执行，使用 time.Sleep()</li> <li>使用 NewTimer()，可以返回的 Timer 类型在计时器到期之前，取消该计时器</li> <li>直到使用 &lt;-timer.C 发送一个值，该计时器才会过期</li></ul> <p>示例：</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">&quot;fmt&quot;</span>
	<span class="token string">&quot;time&quot;</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

	<span class="token comment">/**
		创建一个计数器，d 时间后触发。
		Go 触发计时器的方法比较特别：在 channel 中发送一个值，值为当前时间
	 */</span>
	timer <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">NewTimer</span><span class="token punctuation">(</span><span class="token number">3</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">&quot;timer 的类型：%T\n&quot;</span><span class="token punctuation">,</span> timer<span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;当前时间：&quot;</span><span class="token punctuation">,</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

	<span class="token comment">/**
		此处在等到 channel 中的信号，执行此段代码会阻塞 3s
	 */</span>
	<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		i <span class="token operator">:=</span> <span class="token number">1</span>
		<span class="token keyword">for</span>  <span class="token punctuation">{</span>
			fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;等待第&quot;</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token string">&quot;秒&quot;</span><span class="token punctuation">)</span>
			time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span> <span class="token number">1</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>
			i <span class="token operator">++</span>
		<span class="token punctuation">}</span>

	<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	ch <span class="token operator">:=</span> timer<span class="token punctuation">.</span>C     <span class="token comment">// &lt;- chan time.Time</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;从 timer channel 中收到值：&quot;</span><span class="token punctuation">,</span> <span class="token operator">&lt;-</span>ch<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>输出：</p> <div class="language- extra-class"><pre class="language-text"><code>timer 的类型：*time.Timer
当前时间： 2021-08-02 17:15:16.818942 +0800 CST m=+0.000151763
等待第 1 秒
等待第 2 秒
等待第 3 秒
从 timer channel 中收到值： 2021-08-02 17:15:19.823102 +0800 CST m=+3.004250649
</code></pre></div><p><strong>10.2 timer.Stop()</strong></p> <p><code>timer.Stop()</code> 用于阻止计时器触发。如果 <code>timer.Stop()</code> 成功停止了计时器，它将返回 true，如果计时器已经过期或已经被停止，则返回 false。<code>timer.Stop()</code> <strong>不关闭通道</strong>，这是为了防止错误地从通道读取数据。</p> <p>要确保在调用 <code>timer.Stop()</code> 之后通道是空的，请检查返回值并清空通道。例如，假设程序还没有从 t.C 收到：</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">if</span> <span class="token operator">!</span>t<span class="token punctuation">.</span><span class="token function">Stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token operator">&lt;-</span>t<span class="token punctuation">.</span>C
<span class="token punctuation">}</span>
<span class="token comment">// 这不能与来自计时器通道的其他接收或对计时器 Stop 方法的其他调用同时进行。</span>
<span class="token comment">// 对于使用 AfterFunc(d, f) 创建的计时器，如果 t.Stop 返回 false，则表示计时器已经过期，函数 f 已经在它自己的 goroutine 中启动;</span>
<span class="token comment">// 停止并不等待 f 完成才返回。</span>
<span class="token comment">// 如果调用者需要知道 f 是否完成，它必须显式地与 f 协调。</span>
</code></pre></div><p>示例：</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">&quot;fmt&quot;</span>
	<span class="token string">&quot;time&quot;</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

	<span class="token comment">// 新建一个计时器，5s 后触发</span>
	timer <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">NewTimer</span><span class="token punctuation">(</span><span class="token number">5</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>

	<span class="token comment">// 6s 后停掉计时器</span>
	time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">6</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>
	stopOK <span class="token operator">:=</span> timer<span class="token punctuation">.</span><span class="token function">Stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> stopOK <span class="token punctuation">{</span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;timer stop ok&quot;</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
		v <span class="token operator">:=</span> <span class="token operator">&lt;-</span> timer<span class="token punctuation">.</span>C
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;timer stop not ok, clear channel:&quot;</span><span class="token punctuation">,</span> v<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>输出：</p> <div class="language- extra-class"><pre class="language-text"><code>timer stop not ok, clear channel: 2021-08-02 17:47:39.886786 +0800 CST m=+5.000164114
</code></pre></div><p><strong>10.3 time.After(d)</strong></p> <p><code>time.After(d)</code> 在等待持续时间 d 之后，在返回的通道上发送当前时间。它相当于 NewTimer(d).C。在计时器触发之前，垃圾收集器不会恢复底层计时器。如果效率有问题，使用 NewTimer 代替，并在补需要计时器的时候调用 <code>time.Stop()</code> 停止。</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token function">After</span><span class="token punctuation">(</span>d Duration<span class="token punctuation">)</span> <span class="token operator">&lt;-</span><span class="token keyword">chan</span> Time <span class="token punctuation">{</span>
	<span class="token keyword">return</span> <span class="token function">NewTimer</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">.</span>C
<span class="token punctuation">}</span>
</code></pre></div><p>示例：</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">&quot;fmt&quot;</span>
	<span class="token string">&quot;time&quot;</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	ch <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">After</span><span class="token punctuation">(</span><span class="token number">3</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">&quot;ch type: %T\n&quot;</span><span class="token punctuation">,</span> ch<span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;now:&quot;</span><span class="token punctuation">,</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	time2 <span class="token operator">:=</span> <span class="token operator">&lt;-</span> ch
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;now2:&quot;</span><span class="token punctuation">,</span> time2<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>输出：</p> <div class="language- extra-class"><pre class="language-text"><code>ch type: &lt;-chan time.Time
now: 2021-08-02 18:06:31.213187 +0800 CST m=+0.000132980
now2: 2021-08-02 18:06:34.213613 +0800 CST m=+3.000659583
</code></pre></div><h2 id="六、golang-csp-模型"><a href="#六、golang-csp-模型" class="header-anchor">#</a> 六、Golang CSP 模型</h2> <div class="custom-block tip"><p class="custom-block-title">并发模型：Actors 模型 &amp; CSP 模型</p> <p><strong>并发模型介绍</strong></p> <p>并发模型主要由两种实现的形式：</p> <ol><li>同一个进程下，多个线程天然的共享内存，由程序对读写做同步控制（有锁或无锁）。</li> <li>多个进程通过进程间通讯或者内存映射实现数据的同步。</li></ol> <p><strong>Actors 模型</strong></p> <p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gt2lxicfn4j30jb0620sx.jpg" alt="在这里插入图片描述"></p> <p>Actors 模型更多的使用 <strong>消息机制</strong> 来实现并发，目标是让开发者不再考虑线程这种东西，<strong>每个 Actor 最多同时进行一样工作，Actor 内部可以有自己的变量和数据</strong>。</p> <p>Actors 模型避免了由操作系统进行任务调度的问题，在操作系统进程之上，多个 Actor 可能运行在同一个进程（或线程）中，这就节省了大量的 Context 切换。</p> <p>在 Actors 模型中，每个 Actor 都有一个专属的命名“邮箱”，其他 Actor 可以随时选择一个 Actor 通过邮箱收发数据，对于“邮箱”的维护，通常是使用发布订阅的机制实现的，比如我们可以定义发布者是自己，订阅者可以是某个 Socket 接口，另外的消息总线或者直接是目标 Actor。</p> <p>目前 akka 库是比较流行的 Actors 编程模型实现，支持 Scala 和 Java 语言</p> <p><strong>CSP 模型</strong></p> <p>CSP（Communicating Sequential Process）模型提供一种多个进程公用的“管道（channel）”, 这个 channel 中存放的是一个个“任务”。</p> <p>Go 语言中的 Goroutine 就是参考的 CSP 模型，原始的 CSP 中 channel 里的任务都是立即执行的，而 Go 语言可以为其增加了一个缓存，即任务可以先暂存起来，等待执行进程准备好了再逐个按顺序执行。</p> <p><strong>Actor 与 CSP 的区别</strong></p> <ul><li>CSP 进程通常是同步的（即任务被推送进 channel 就立即执行，如果任务执行的线程正忙，则发送者就暂时无法推送新任务），Actor 进程通常是异步的（消息传递给 Actor 后并不一定马上执行）。</li> <li>在 CSP 中，我们需要一个中介，也就是 channel 来进行消息传递，在 Actor 中我们可以直接从一个 Actor 往另一个 Actor 传输数据。无需中介。</li></ul></div> <p>Go 语言的 CSP 模型是由协程 Goroutine 与通道 channel 实现：</p> <ul><li>Goroutine：是一种轻量线程，它不是操作系统的线程，而是将一个操作系统线程分段使用，通过调度器实现协作式调度。是一种绿色线程，微线程，它与 Coroutine 协程也有区别，能够在发现堵塞后启动新的微线程。</li> <li>channel：类似 Unix 的 Pipe，用于协程之间通讯和同步。协程之间虽然解耦，但是它们和 channel 有着耦合。</li></ul> <!----></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">8/2/2021, 6:20:14 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/noteSite/backend/golang/02_grammar/error.html" class="prev">
        Golang 异常处理
      </a></span> <span class="next"><a href="/noteSite/backend/golang/high/reflect.html">
        Golang 反射
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/noteSite/assets/js/app.47f3dd69.js" defer></script><script src="/noteSite/assets/js/2.691adf44.js" defer></script><script src="/noteSite/assets/js/25.333b798b.js" defer></script>
  </body>
</html>
