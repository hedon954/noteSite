(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{448:function(t,a,_){"use strict";_.r(a);var v=_(47),s=Object(v.a)({},(function(){var t=this,a=t.$createElement,_=t._self._c||a;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"javase-bio-nio-aio"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#javase-bio-nio-aio"}},[t._v("#")]),t._v(" JavaSE —— BIO/NIO/AIO")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/008i3skNgy1gujef9kl0hj61xu0rggts02.jpg",alt:"image-20210917100721976"}})]),t._v(" "),_("h2",{attrs:{id:"一、网络编程基础"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#一、网络编程基础"}},[t._v("#")]),t._v(" 一、网络编程基础")]),t._v(" "),_("h3",{attrs:{id:"_1-url-的解析和构造"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-url-的解析和构造"}},[t._v("#")]),t._v(" 1. URL 的解析和构造")]),t._v(" "),_("img",{staticStyle:{zoom:"25%"},attrs:{src:"https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/008i3skNgy1gujenl60kpj61so0aeq5502.jpg",alt:"image-20210917101524042"}}),t._v(" "),_("div",{staticClass:"custom-block tip"},[_("p",{staticClass:"custom-block-title"},[t._v("URI 和 URL 的区别与联系")]),t._v(" "),_("ul",[_("li",[t._v("URI: Uniform Resource Identifier")]),t._v(" "),_("li",[t._v("URL: Uniform Resource Locator")]),t._v(" "),_("li",[t._v("URN: Uniform Resource Name")])]),t._v(" "),_("p",[t._v("URI 是抽象的定义，不管用什么方法表示，只要能定位一个资源，就叫 URI，本来设想的的使用两种方法定位：")]),t._v(" "),_("ol",[_("li",[t._v("URL：用地址定位")]),t._v(" "),_("li",[t._v("URN：用名称定位")])])]),t._v(" "),_("h3",{attrs:{id:"_2-dns-解析"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-dns-解析"}},[t._v("#")]),t._v(" 2. DNS 解析")]),t._v(" "),_("p",[t._v("域名 -> IP 地址")]),t._v(" "),_("h3",{attrs:{id:"_3-网络协议"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-网络协议"}},[t._v("#")]),t._v(" 3. 网络协议")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/008i3skNgy1gujeyyroq8j60u016ijy802.jpg",alt:"img"}})]),t._v(" "),_("h3",{attrs:{id:"_4-java-io"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-java-io"}},[t._v("#")]),t._v(" 4. Java IO")]),t._v(" "),_("ul",[_("li",[t._v("参考："),_("RouterLink",{attrs:{to:"/backend/java/high/io.html"}},[t._v("JavaSE —— IO")])],1)]),t._v(" "),_("h3",{attrs:{id:"_5-socket"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-socket"}},[t._v("#")]),t._v(" 5. Socket")]),t._v(" "),_("p",[t._v("对于底层网络应用开发者而言，几乎所有网络编程都是 Socket，因为大部分底层网络 的编程都离不开 Socket 编程。 HTTP 编程、 Web 开发、 IM 通信 、视频流传输的底层都是 Socket 编程 。")]),t._v(" "),_("p",[t._v("日常生活中我们每天打开浏览器浏览网页、使用 QQ 聊天、 邮件收发、 直播等，客户端和服务器端的通信在底层看来都是依靠 Socket 通信的。")]),t._v(" "),_("p",[t._v("Socket 起源于 UNIX，而 UNIX 的基本哲学之一就是“一切皆文件”，都可以用 "),_("strong",[t._v("“打开（open）→读写（write/read）→关闭（close）”")]),t._v(" 模式来操作， Socket 就是该模式的一个实现，网络的 Socket 数据传输是 一种特殊的 I/0，Socket 也是一种文件描述符。 Socket 也具有一个类似于打开文件的函数调用：Socket()， 该函数返回一个整型的 Socket 描述符， 随后的连接建立、数据传输等操作都是通过该 Socket 实现的 。")]),t._v(" "),_("p",[t._v("网络中的进程之间如何通过 Socket 通信呢？首要解决的问题是如何唯一标识一个进程，否则通信无从谈起 ! 在本地可以通过进程 PID 来唯一标识一个进程，但是在网络中这是行不通的。其实 TCP/IP 协议族己经帮我们解决了这个问题，网络层的“IP 地址”可以唯一标识网络中的主机，而传输层的“协议+端口” 可以唯一标识主机中的应用程序（进程）。这样利用三大要素（"),_("strong",[t._v("IP 地址")]),t._v("、"),_("strong",[t._v("协议")]),t._v("、"),_("strong",[t._v("端口")]),t._v("）就可以标识网络的进程了，网络中需要互相通信的进程，就可以利用这个标志在它们之间进行交互。")]),t._v(" "),_("p",[t._v("使用 TCP/IP 协议的应用程序通常采用应用编程接口：UNIX BSD 的套接字和 UNIX System V 的 TLI（己经被淘汰），来实现网络进程之间的通信。就目前而言， 几乎所有的应用程序都是采用 Socket，而现在又是网络时代，网络中进程通信是无处不在的，这就是为什么说“一切皆 Socket”。")]),t._v(" "),_("p",[t._v("Socket 有两种：")]),t._v(" "),_("ul",[_("li",[t._v("TCPSocket")]),t._v(" "),_("li",[t._v("UDP Socket")])]),t._v(" "),_("p",[t._v("TCP 和 UDP 是协议，而要确定一个进程得需要三要素， 所以还需要 IP 地址和端口。")]),t._v(" "),_("h3",{attrs:{id:"_6-阻塞-非阻塞-vs-异步-同步"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-阻塞-非阻塞-vs-异步-同步"}},[t._v("#")]),t._v(" 6. 阻塞/非阻塞 vs 异步/同步")]),t._v(" "),_("p",[_("strong",[t._v("阻塞/非阻塞")])]),t._v(" "),_("blockquote",[_("p",[t._v("👀 从调用方的角度来看）")])]),t._v(" "),_("ul",[_("li",[t._v("如果调用方在被调用方返回结果之前只能傻傻等待，那就是阻塞的。")]),t._v(" "),_("li",[t._v("如果调用方在被调用方返回结果之前可以先干别的事情，那就是非阻塞的。")])]),t._v(" "),_("p",[_("strong",[t._v("同步/异步")])]),t._v(" "),_("blockquote",[_("p",[t._v("（从被调用方的角度来看👀")])]),t._v(" "),_("ul",[_("li",[t._v("如果被调用方被调用之后需要立刻返回结果，那么就是同步的。")]),t._v(" "),_("li",[t._v("如果被调用方被调用之后先返回一个空的结果，等到任务执行完成后再通知调用方，那就是异步的。")])]),t._v(" "),_("blockquote",[_("p",[t._v("同步和异步的区别：是否开启新线程。")]),t._v(" "),_("p",[t._v("阻塞和非阻塞的区别：当前线程是否挂起，即是否释放 CPU。")])]),t._v(" "),_("h3",{attrs:{id:"_7-linux-5-种-io"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7-linux-5-种-io"}},[t._v("#")]),t._v(" 7. Linux 5 种 IO")]),t._v(" "),_("ul",[_("li",[t._v("参考："),_("RouterLink",{attrs:{to:"/linux/linux-io/0-concept.html"}},[t._v("Linux IO")])],1)]),t._v(" "),_("h2",{attrs:{id:"二、bio"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#二、bio"}},[t._v("#")]),t._v(" 二、BIO")]),t._v(" "),_("h3",{attrs:{id:"_1-简介"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-简介"}},[t._v("#")]),t._v(" 1. 简介")]),t._v(" "),_("ul",[_("li",[t._v("Java BIO 就是传统的 java io 编程，其相关接口在 java.io。")]),t._v(" "),_("li",[t._v("BIO（Blocking I/O）：同步阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时，服务器端就需要一个启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，可以通过线程池机制改善（实现多个客户连接服务器）。")]),t._v(" "),_("li",[t._v("BIO 适用于连接数目较小且固定架构，这种方式对服务器资源要求较高，并发局限于应用中，JDK1.4 之前的唯一选择，程序简单易理解。")])]),t._v(" "),_("div",{staticClass:"language-markdown extra-class"},[_("pre",{pre:!0,attrs:{class:"language-markdown"}},[_("code",[_("span",{pre:!0,attrs:{class:"token title important"}},[_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("#")]),t._v(" 阻塞体现在哪里？")]),t._v("\naccept() ：阻塞接收客户端的连接\nread()/write()\nconnect()：和服务端建立连接，连接的过程中 connect() 会阻塞\n")])])]),_("h3",{attrs:{id:"_2-基本流程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-基本流程"}},[t._v("#")]),t._v(" 2. 基本流程")]),t._v(" "),_("ol",[_("li",[t._v("服务器启动一个 ServerSocket；")]),t._v(" "),_("li",[t._v("客户端启动 Socket 对服务器进行通信，默认情况下服务器需要对每个客户建立一个线程与之通讯；")]),t._v(" "),_("li",[t._v("客户端发出请求后，先咨询服务器，是否有线程响应，如果没有则会等待，或者被拒绝；")]),t._v(" "),_("li",[t._v("如果有响应，客户端线程会等待请求结束后，再继续执行。")])]),t._v(" "),_("h3",{attrs:{id:"_3-缺点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-缺点"}},[t._v("#")]),t._v(" 3. 缺点")]),t._v(" "),_("ol",[_("li",[t._v("每个请求都需要创建独立线程，与对应的客户端进行数据 Read 业务处理，数据 Write。")]),t._v(" "),_("li",[t._v("当并发数量较大，需要"),_("strong",[t._v("创建大量线程来处理连接")]),t._v("，系统资源占用较大。")]),t._v(" "),_("li",[t._v("连接建立后，如果当前线程没有数据可读，则线程就阻塞在 Read 操作上，造成线程资源浪费。")])]),t._v(" "),_("h3",{attrs:{id:"_4-实战多人聊天室"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-实战多人聊天室"}},[t._v("#")]),t._v(" 4. 实战多人聊天室")]),t._v(" "),_("h4",{attrs:{id:"_4-1-架构设计"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-架构设计"}},[t._v("#")]),t._v(" 4.1 架构设计")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/008i3skNgy1gujwxoq4aoj60pq0we76502.jpg",alt:"bio-chatroom-sequence-diagram"}})]),t._v(" "),_("p",[t._v("服务端：")]),t._v(" "),_("ul",[_("li",[t._v("一个线程来负责添加和删除客户端，并维护一个在线的客户端列表；")]),t._v(" "),_("li",[t._v("一个线程来负责接收和广播客户端的信息；")])]),t._v(" "),_("p",[t._v("客户端：")]),t._v(" "),_("ul",[_("li",[t._v("一个线程来负责等待用户输入；")]),t._v(" "),_("li",[t._v("一个线程来负责接收其他客户端发来的信息；")])]),t._v(" "),_("h4",{attrs:{id:"_4-2-服务端实现"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-服务端实现"}},[t._v("#")]),t._v(" 4.2 服务端实现")]),t._v(" "),_("ul",[_("li",[t._v("ChatServer")]),t._v(" "),_("li",[t._v("ChatHandler")]),t._v(" "),_("li",[t._v("ChatServerStarter")])]),t._v(" "),_("h4",{attrs:{id:"_4-3-客户端实现"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-客户端实现"}},[t._v("#")]),t._v(" 4.3 客户端实现")]),t._v(" "),_("ul",[_("li",[t._v("ChatClient")]),t._v(" "),_("li",[t._v("UserInputHandler")]),t._v(" "),_("li",[t._v("ChatClientStarter")])]),t._v(" "),_("h4",{attrs:{id:"_4-4-演示"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-4-演示"}},[t._v("#")]),t._v(" 4.4 演示")]),t._v(" "),_("h2",{attrs:{id:"三、nio"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#三、nio"}},[t._v("#")]),t._v(" 三、NIO")]),t._v(" "),_("h2",{attrs:{id:"四、aio"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#四、aio"}},[t._v("#")]),t._v(" 四、AIO")]),t._v(" "),_("Vssue")],1)}),[],!1,null,null,null);a.default=s.exports}}]);