(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{454:function(_,t,v){"use strict";v.r(t);var s=v(47),a=Object(s.a)({},(function(){var _=this,t=_.$createElement,v=_._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h1",{attrs:{id:"十、redis-集群分片"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#十、redis-集群分片"}},[_._v("#")]),_._v(" 十、Redis 集群分片")]),_._v(" "),v("h2",{attrs:{id:"_1-集群介绍"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-集群介绍"}},[_._v("#")]),_._v(" 1. 集群介绍")]),_._v(" "),v("p",[_._v("集群（cluster）就是一组计算机，它们作为一个整体向用户提供一组网络资源，这些单个的计算机系统就是集群的节点（node）。集群提供了以下关键的特性：")]),_._v(" "),v("ul",[v("li",[_._v("可扩展性")]),_._v(" "),v("li",[_._v("高可用性")]),_._v(" "),v("li",[_._v("负载均衡")]),_._v(" "),v("li",[_._v("错误恢复")])]),_._v(" "),v("p",[_._v("分布式与集群的联系与区别如下：")]),_._v(" "),v("ul",[v("li",[_._v("分布式即各个业务分开部署，集群指的是几台服务器集中在一起实现同一个业务。")]),_._v(" "),v("li",[_._v("分布式的每一个节点都可以做成集群，而集群并不一定就是分布式的。")])]),_._v(" "),v("p",[_._v("集群主要分为三大类：")]),_._v(" "),v("ul",[v("li",[_._v("HA（High Availability Cluster）：高可用集群")]),_._v(" "),v("li",[_._v("LBC（Load Balance Cluster）：负载均衡集群")]),_._v(" "),v("li",[_._v("HPC（High Performance Computing Cluster）：高性能集群")])]),_._v(" "),v("h2",{attrs:{id:"_2-redis-集群架构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-redis-集群架构"}},[_._v("#")]),_._v(" 2. Redis 集群架构")]),_._v(" "),v("h3",{attrs:{id:"_2-1-架构简介"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-架构简介"}},[_._v("#")]),_._v(" 2.1 架构简介")]),_._v(" "),v("ul",[v("li",[_._v("并发量大了 → 主从复制解决 → 主从稳定性 → 哨兵解决 → 单节点存储能力 → 集群 Cluster 解决")]),_._v(" "),v("li",[_._v("Redis Cluster 集群模式具有高可用、可扩展性、分布式、容错等特性。")])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://tva1.sinaimg.cn/large/008i3skNly1gt6vbt70waj30hs0c5js8.jpg",alt:"img"}})]),_._v(" "),v("p",[_._v("Redis Cluster 采用无中心结构，每个节点都可以保存数据和整个集群状态，每个节点都和其他所有节点连接，Cluster 至少为 6 个才能保证组成完成高可用集群，分为 3 主 3 从。主节点分配槽，处理客户端的命令请求，从节点可用在主节点故障后，顶替主节点。")]),_._v(" "),v("div",{staticClass:"custom-block warning"},[v("p",{staticClass:"custom-block-title"},[_._v("为什么至少 6 台呢？")]),_._v(" "),v("p",[_._v("我们可以在 Redis 官方找到这么一句话：")]),_._v(" "),v("blockquote",[v("p",[_._v("Note that the minial cluster that works as expected requires to contain at least three master nodes.")])]),_._v(" "),v("p",[_._v("因为最小的 Redis 集群，需要至少 3 个主节点（哨兵），既然有 3 个主节点，而一个主节点搭配至少一个从节点，因此至少得 6 台 Redis。")])]),_._v(" "),v("p",[_._v("如上图所示，该集群中包括 6 个 Redis 节点，3 主 3 从，分别为 M1、M2、M3、S1、S2、S3。除了主从 Redis 节点之间进行数据复制外，锁有 Redis 节点之间采用 Gossip 协议进行通信，交换维护节点元数据信息。")]),_._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[_._v("Gossip")])]),_._v(" "),v("h3",{attrs:{id:"_2-2-主从模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-主从模式"}},[_._v("#")]),_._v(" 2.2 主从模式")]),_._v(" "),v("ul",[v("li",[_._v("一个主节点搭配一个或多个从节点，从而保证高可用。")])]),_._v(" "),v("h3",{attrs:{id:"_2-3-优点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-优点"}},[_._v("#")]),_._v(" 2.3 优点")]),_._v(" "),v("ul",[v("li",[_._v("去中心化")]),_._v(" "),v("li",[_._v("可扩展性")]),_._v(" "),v("li",[_._v("高可用性")]),_._v(" "),v("li",[_._v("自动故障转移")])]),_._v(" "),v("h3",{attrs:{id:"_2-4-缺点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-缺点"}},[_._v("#")]),_._v(" 2.4 缺点")]),_._v(" "),v("ul",[v("li",[_._v("数据通过异步复制，无法保证数据强一致性")]),_._v(" "),v("li",[_._v("集群环境搭建略微复杂")])]),_._v(" "),v("h2",{attrs:{id:"_3-数据分区方式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-数据分区方式"}},[_._v("#")]),_._v(" 3. 数据分区方式")]),_._v(" "),v("p",[_._v("随着请求量和数据量的增加，一台机器已经无法满足需求，我们就需要把数据和请求分割到多台机器，这时候就需要引入分布式存储。分布式分成有以下几个特性：")]),_._v(" "),v("ul",[v("li",[_._v("增强可用性")]),_._v(" "),v("li",[_._v("维护方便")]),_._v(" "),v("li",[_._v("均衡 IO")]),_._v(" "),v("li",[_._v("改善查询性能")])]),_._v(" "),v("p",[_._v("分布式存储首先要解决的就是把整个数据集安全分区规则映射到多个节点的问题。")]),_._v(" "),v("p",[_._v("下面介绍几个常见的分区算法。")]),_._v(" "),v("h3",{attrs:{id:"_3-1-范围分区"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-范围分区"}},[_._v("#")]),_._v(" 3.1 范围分区")]),_._v(" "),v("ul",[v("li",[_._v("优点：同一范围内的范围查询不需要跨节点，提升查询速度")]),_._v(" "),v("li",[_._v("应用场景：MySQL、Oracle")])]),_._v(" "),v("h3",{attrs:{id:"_3-2-节点取余分区"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-节点取余分区"}},[_._v("#")]),_._v(" 3.2 节点取余分区")]),_._v(" "),v("p",[_._v("hash(object) % N")]),_._v(" "),v("ul",[v("li",[_._v("优点：实现简单，数据均匀分摊")]),_._v(" "),v("li",[_._v("缺点：当扩容或缩容节点时，需要迁移的数据量大（翻倍扩容可以相对减少迁移量）。")])]),_._v(" "),v("h3",{attrs:{id:"_3-3-一致性哈希分区"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-一致性哈希分区"}},[_._v("#")]),_._v(" 3.3 一致性哈希分区")]),_._v(" "),v("ul",[v("li",[_._v("优点：相比节点取余最大的好处在于加入和删除节点只影响哈希环中相邻的节点，对其他节点无影响。")]),_._v(" "),v("li",[_._v("缺点：当使用少量节点时，节点变化将大范围影响哈希环中数据映射，因此这种方式不适合少量数据节点的分布式方案。")]),_._v(" "),v("li",[_._v("应用场景：Memcached")])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://tva1.sinaimg.cn/large/008i3skNly1gt6wrph6gnj30hz0dddgo.jpg",alt:"img"}})]),_._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[_._v("一致性哈希算法")]),_._v(" "),v("blockquote",[v("p",[_._v("参考：https://zhuanlan.zhihu.com/p/98030096")])]),_._v(" "),v("p",[v("strong",[_._v("1. 普通 hash 算法在分布式系统中的缺陷")])]),_._v(" "),v("p",[_._v("在分布式的存储系统中，要将数据存储到具体的节点上，如果我们采用普通的 hash 算法进行路由，将数据映射到具体的节点上，如 key%N，key 是数据的 key，N是 机器节点数，如果有一个机器加入或退出这个集群，则所有的数据映射都无效了，如果是持久化存储则要做数据迁移，如果是分布式缓存，则其他缓存就失效了。")]),_._v(" "),v("p",[v("strong",[_._v("2. 一致性哈希")])]),_._v(" "),v("p",[_._v("一致性哈希提出了在动态变化的 Cache 环境中，哈希算法应该满足的 4 个适应条件：")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("均衡性（Balance）")]),_._v(" "),v("p",[_._v("平衡性是指哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用。很多哈希算法都能够满足这一条件。")])]),_._v(" "),v("li",[v("p",[_._v("单调性（Monotonicity）")]),_._v(" "),v("p",[_._v("单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲区加入到系统中，那么哈希的结果应能够保证原有已分配的内容可以被映射到新的缓冲区中去，而不会被映射到旧的缓冲集合中的其他缓冲区。（"),v("strong",[_._v("这段翻译信息有负面价值的，当缓冲区大小变化时一致性哈希（Consistent hashing）尽量保护已分配的内容不会被重新映射到新缓冲区。")]),_._v("）")])]),_._v(" "),v("li",[v("p",[_._v("低分散性（Spread）")]),_._v(" "),v("p",[_._v("在分布式环境中，终端有可能看不到所有的缓冲，而是只能看到其中的一部分。当终端希望通过哈希过程将内容映射到缓冲上时，由于不同终端所见的缓冲范围有可能不同，从而导致哈希的结果不一致，最终的结果是相同的内容被不同的终端映射到不同的缓冲区中。这种情况显然是应该避免的，因为它导致相同内容被存储到不同缓冲中去，降低了系统存储的效率。分散性的定义就是上述情况发生的严重程度。好的哈希算法应能够尽量避免不一致的情况发生，也就是尽量降低分散性。")])]),_._v(" "),v("li",[v("p",[_._v("低负载（Load）")]),_._v(" "),v("p",[_._v("负载问题实际上是从另一个角度看待分散性问题。既然不同的终端可能将相同的内容映射到不同的缓冲区中，那么对于一个特定的缓冲区而言，也可能被不同的用户映射为不同的内容。与分散性一样，这种情况也是应当避免的，因此好的哈希算法应能够尽量降低缓冲的负荷。")])])]),_._v(" "),v("p",[v("strong",[_._v("3. 一致性哈希算法实现")])]),_._v(" "),v("ul",[v("li",[v("p",[_._v("环形 hash 空间")]),_._v(" "),v("p",[_._v("按照常用的 hash 算法来将对应的 key 哈希到一个具有 2"),v("sup",[_._v("32")]),_._v(" 次方个节点的空间中，即 0 ~ （2"),v("sup",[_._v("32")]),_._v("-1）的数字空间中。现在我们可以将这些数字头尾相连，想象成一个闭合的环形。")]),_._v(" "),v("center")],1),_._v(" "),v("li",[v("p",[_._v("映射服务器节点")])]),_._v(" "),v("li",[v("p",[_._v("映射数据")])]),_._v(" "),v("li",[v("p",[_._v("节点的删除与增加")])]),_._v(" "),v("li",[v("p",[_._v("虚拟节点")])]),_._v(" "),v("li")])]),_._v(" "),v("h3",{attrs:{id:"_3-4-虚拟槽分区"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-虚拟槽分区"}},[_._v("#")]),_._v(" 3.4 虚拟槽分区")]),_._v(" "),v("h2",{attrs:{id:"_4-集群环境搭建"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-集群环境搭建"}},[_._v("#")]),_._v(" 4. 集群环境搭建")]),_._v(" "),v("h2",{attrs:{id:"_5-集群环境测试"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-集群环境测试"}},[_._v("#")]),_._v(" 5. 集群环境测试")]),_._v(" "),v("h2",{attrs:{id:"_6-性能测试"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6-性能测试"}},[_._v("#")]),_._v(" 6. 性能测试")]),_._v(" "),v("h2",{attrs:{id:"_7-集群原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_7-集群原理"}},[_._v("#")]),_._v(" 7. 集群原理")]),_._v(" "),v("Vssue")],1)}),[],!1,null,null,null);t.default=a.exports}}]);