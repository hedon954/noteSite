(window.webpackJsonp=window.webpackJsonp||[]).push([[92],{504:function(a,_,v){"use strict";v.r(_);var t=v(47),s=Object(t.a)({},(function(){var a=this,_=a.$createElement,v=a._self._c||_;return v("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[v("h1",{attrs:{id:"五、监控工具"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#五、监控工具"}},[a._v("#")]),a._v(" 五、监控工具")]),a._v(" "),v("h2",{attrs:{id:"_1-如何把-java-内存的数据全部-dump-出来"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-如何把-java-内存的数据全部-dump-出来"}},[a._v("#")]),a._v(" 1. 如何把  Java 内存的数据全部 dump 出来")]),a._v(" "),v("ol",[v("li",[a._v("启动的时候进行配置 "),v("code",[a._v("-XX:+HeapDumpOnOutOfMemoryError")]),a._v(" + "),v("code",[a._v("+XX:HeapDumpPath")]),a._v("。")]),a._v(" "),v("li",[a._v("jmap 命令可以用来查看堆内存使用状况："),v("code",[a._v("jmap [option] pid")]),a._v("。")]),a._v(" "),v("li",[a._v("在 jmc 或者 visualvm 进行导出。")])]),a._v(" "),v("h2",{attrs:{id:"_2-jstack-的作用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-jstack-的作用"}},[a._v("#")]),a._v(" 2. jstack 的作用？")]),a._v(" "),v("p",[a._v("jstack 主要用来查看某个 Java 进程内的线程堆栈信息："),v("code",[a._v("jstack [option] pid")]),a._v("。")]),a._v(" "),v("h2",{attrs:{id:"_3-jstat-的作用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-jstat-的作用"}},[a._v("#")]),a._v(" 3. jstat 的作用？")]),a._v(" "),v("p",[a._v("JVM 统计监测工具，查看各个区内存和 GC 的情况。")]),a._v(" "),v("h2",{attrs:{id:"_4-如何定位问题-如何解决问题-说一下解决思路和处理方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-如何定位问题-如何解决问题-说一下解决思路和处理方法"}},[a._v("#")]),a._v(" 4. 如何定位问题？如何解决问题？说一下解决思路和处理方法")]),a._v(" "),v("ul",[v("li",[a._v("visualvm 或 jmc 查看内存情况、GC 情况。")]),a._v(" "),v("li",[a._v("注意各种特征，考虑是否存在死锁，考虑大对象的分配问题，考虑 GC 的频率和时长和算法选择。")])]),a._v(" "),v("h2",{attrs:{id:"_5-cpu-使用率过高怎么办"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-cpu-使用率过高怎么办"}},[a._v("#")]),a._v(" 5. CPU 使用率过高怎么办？")]),a._v(" "),v("ul",[v("li",[a._v("用 visualvm 的飞行记录仪记录一段时间，然后看看哪些是热门的线程，分析这些线程的执行情况。")]),a._v(" "),v("li",[a._v("考虑线程死锁、线程竞争资源。")]),a._v(" "),v("li",[a._v("考虑 IO。")]),a._v(" "),v("li",[a._v("考虑 socket。")])]),a._v(" "),v("h2",{attrs:{id:"_6-线上应用频繁-full-gc-如何处理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6-线上应用频繁-full-gc-如何处理"}},[a._v("#")]),a._v(" 6. 线上应用频繁 Full GC 如何处理？")]),a._v(" "),v("ul",[v("li",[a._v("内存设置可能有问题，整个堆的大小可能过小")]),a._v(" "),v("li",[a._v("新生代和老年代的比例不妥当。")]),a._v(" "),v("li",[a._v("用飞行记录仪记录，然后分析新生代和老年代的上限是怎样的。")]),a._v(" "),v("li",[a._v("检查代码是否频繁分配大对象，看看能不能复用大对象或者及时释放大对象。")]),a._v(" "),v("li",[a._v("GC 收集器选择是否合理，参数设置是否合理。")])]),a._v(" "),v("h2",{attrs:{id:"_7-如果应用周期性地出现卡顿-你会怎么来排查这个问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_7-如果应用周期性地出现卡顿-你会怎么来排查这个问题"}},[a._v("#")]),a._v(" 7. 如果应用周期性地出现卡顿，你会怎么来排查这个问题？")]),a._v(" "),v("ul",[v("li",[a._v("多数是 Full GC 导致是 STW，考虑应用如何规避 Full GC 的发生，或者降低 Full GC 的频率。")]),a._v(" "),v("li",[a._v("比如增大堆内存，增大老年代比例。")]),a._v(" "),v("li",[a._v("具体需要用 visualvm 监控然后根据具体情况分析。")])]),a._v(" "),v("h2",{attrs:{id:"_8-oom问题如何处理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_8-oom问题如何处理"}},[a._v("#")]),a._v(" 8. OOM问题如何处理？")]),a._v(" "),v("ul",[v("li",[a._v("内存泄露。")]),a._v(" "),v("li",[a._v("对象分配但是没有回收。")])]),a._v(" "),v("h2",{attrs:{id:"_9-stackoverflow"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_9-stackoverflow"}},[a._v("#")]),a._v(" 9. StackOverFlow")]),a._v(" "),v("ul",[v("li",[a._v("死循环")]),a._v(" "),v("li",[a._v("死递归")]),a._v(" "),v("li",[a._v("Java 栈大小分配可能过小")])]),a._v(" "),v("Vssue")],1)}),[],!1,null,null,null);_.default=s.exports}}]);